[{"content":"★MyBatis基础 1.什么是MyBatis？ MyBatis是一个实现了数据持久化的开源框架，这句话的终点是数据持久化。问题来了，什么是数据持久化呢？百度百科给出的解释是：\n “数据持久化就是将内存中的数据模型转换为存储模型，以及将存储模型转换为内存中的数据模型的统称。 数据模型可以是任何数据结构或对象模型,存储模型可以是关系模型、XML、二进制流等。”\n 但是对于现阶段的我这个菜鸟俩说，只需要记得数据持久化就是把数据存到数据库中即可（Java对象模型和关系模型之间的对应）。\n2.如何使用MyBatis？(准备阶段)   创建Maven工程，配置pom.xml相关的依赖\n1 2 3 4 5 6 7 8 9 10 11  \u0026lt;dependency\u0026gt;\r\u0026lt;groupId\u0026gt;org.mybatis\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;mybatis\u0026lt;/artifactId\u0026gt;\r\u0026lt;version\u0026gt;3.5.4\u0026lt;/version\u0026gt;\r\u0026lt;/dependency\u0026gt;\r\u0026lt;dependency\u0026gt;\r\u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt;\r\u0026lt;version\u0026gt;8.0.18\u0026lt;/version\u0026gt;\r\u0026lt;/dependency\u0026gt;\r    在mybatis数据库中新建数据表\n1 2 3 4 5 6  create table t_user(\rid int primary key auto_increment,\rusername varchar(11),\rpassword varchar(11),\rage int\r)\r    在Java代码中创建数据表t_user对应的实体类tech.langchao2020.entity.User\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  public class User {\rprivate int id;\rprivate String username;\rprivate String password;\rprivate int age;\rpublic int getId() {\rreturn id;\r}\rpublic void setId(int id) {\rthis.id = id;\r}\rpublic String getUsername() {\rreturn username;\r}\rpublic void setUsername(String username) {\rthis.username = username;\r}\rpublic String getPassword() {\rreturn password;\r}\rpublic void setPassword(String password) {\rthis.password = password;\r}\rpublic int getAge() {\rreturn age;\r}\rpublic void setAge(int age) {\rthis.age = age;\r}\r@Override\rpublic String toString() {\rreturn \u0026#34;User{\u0026#34; +\r\u0026#34;id=\u0026#34; + id +\r\u0026#34;, username=\u0026#39;\u0026#34; + username + \u0026#39;\\\u0026#39;\u0026#39; +\r\u0026#34;, password=\u0026#39;\u0026#34; + password + \u0026#39;\\\u0026#39;\u0026#39; +\r\u0026#34;, age=\u0026#34; + age +\r\u0026#39;}\u0026#39;;\r}\r}\r    添加MyBatis配置文件\\src\\main\\resources\\mybatis-config.xml文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt;\r\u0026lt;!DOCTYPE configuration PUBLIC \u0026#34;-//mybatis.org//DTD Config 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-config.dtd\u0026#34;\u0026gt;\r\u0026lt;configuration\u0026gt;\r\u0026lt;!--配置MyBatis运行环境 --\u0026gt;\r\u0026lt;environments default=\u0026#34;development\u0026#34;\u0026gt;\r\u0026lt;environment id=\u0026#34;development\u0026#34;\u0026gt;\r\u0026lt;!--配置JDBC事务管理 --\u0026gt;\r\u0026lt;transactionManager type=\u0026#34;JDBC\u0026#34;/\u0026gt;\r\u0026lt;!--POOLED配置JDBC数据源连接池 --\u0026gt;\r\u0026lt;dataSource type=\u0026#34;POOLED\u0026#34;\u0026gt;\r\u0026lt;property name=\u0026#34;driver\u0026#34; value=\u0026#34;com.mysql.cj.jdbc.Driver\u0026#34;/\u0026gt;\r\u0026lt;property name=\u0026#34;url\u0026#34;\rvalue=\u0026#34;jdbc:mysql://120.24.207.216:3306/mybatis?useUnicode=true\u0026amp;amp;characterEncoding=UTF-8\u0026#34;/\u0026gt;\r\u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt;\r\u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;xxxxx\u0026#34;/\u0026gt;\r\u0026lt;/dataSource\u0026gt;\r\u0026lt;/environment\u0026gt;\r\u0026lt;/environments\u0026gt;\r\u0026lt;/configuration\u0026gt;\r    3.MyBatis开发的两种方式  使用原生接口 使用Mapper代理实现自定义接口  1.使用原生接口开发 步骤1：在tech.langchao2020.mapper下创建UserMapper.xml文件；namespace通常设置为文件所在包名+文件名，parameterType为参数数据类型，resultType为返回值数据类型。\n1 2 3 4 5 6 7 8 9  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt;\r\u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt;\r\u0026lt;mapper namespace=\u0026#34;com.southwind.mapper.UserMapper\u0026#34;\u0026gt;\r\u0026lt;select id=\u0026#34;get\u0026#34; parameterType=\u0026#34;int\u0026#34; resultType=\u0026#34;tech.langchao2020.entity.User\u0026#34;\u0026gt;\rselect * from user where id=#{id}\r\u0026lt;/select\u0026gt;\r\u0026lt;/mapper\u0026gt;\r   namespace 通常设置为⽂文件所在包+⽂文件名的形式。 insert 标签表示执⾏行行添加操作。 select 标签表示执⾏行行查询操作。 update 标签表示执⾏行行更更新操作。 delete 标签表示执⾏行行删除操作。 id 是实际调⽤用 MyBatis ⽅方法时需要⽤用到的参数。 parameterType 是调⽤用对应⽅方法时参数的数据类型。  步骤2：在\\src\\main\\resources\\mybatis-config.xml配置文件中注册UseMapper.xml`文件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt;\r\u0026lt;!DOCTYPE configuration PUBLIC \u0026#34;-//mybatis.org//DTD Config 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-config.dtd\u0026#34;\u0026gt;\r\u0026lt;configuration\u0026gt;\r\u0026lt;!--配置MyBatis运行环境 --\u0026gt;\r\u0026lt;environments default=\u0026#34;development\u0026#34;\u0026gt;\r\u0026lt;environment id=\u0026#34;development\u0026#34;\u0026gt;\r\u0026lt;!--配置JDBC事务管理 --\u0026gt;\r\u0026lt;transactionManager type=\u0026#34;JDBC\u0026#34;/\u0026gt;\r\u0026lt;!--POOLED配置JDBC数据源连接池 --\u0026gt;\r\u0026lt;dataSource type=\u0026#34;POOLED\u0026#34;\u0026gt;\r\u0026lt;property name=\u0026#34;driver\u0026#34; value=\u0026#34;com.mysql.cj.jdbc.Driver\u0026#34;/\u0026gt;\r\u0026lt;property name=\u0026#34;url\u0026#34;\rvalue=\u0026#34;jdbc:mysql://120.24.207.216:3306/mybatis?useUnicode=true\u0026amp;amp;characterEncoding=UTF-8\u0026#34;/\u0026gt;\r\u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt;\r\u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;xxxxx\u0026#34;/\u0026gt;\r\u0026lt;/dataSource\u0026gt;\r\u0026lt;/environment\u0026gt;\r\u0026lt;/environments\u0026gt;\r\u0026lt;mappers\u0026gt;\r\u0026lt;mapper resource=\u0026#34;tech/langchao2020/mapper/UserMapper.xml\u0026#34;/\u0026gt;\r\u0026lt;/mappers\u0026gt;\r\u0026lt;/configuration\u0026gt;\r  步骤3，在tech.langchao2020.test创建Test类测试。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  package tech.langchao2020.test;\rimport org.apache.ibatis.session.SqlSession;\rimport org.apache.ibatis.session.SqlSessionFactory;\rimport org.apache.ibatis.session.SqlSessionFactoryBuilder;\rimport tech.langchao2020.entity.User;\rimport java.io.InputStream;\rpublic class Test {\rpublic static void main(String[] args) {\r//加载MyBatis配置文件\r InputStream is = Test.class.getClassLoader().getResourceAsStream(\u0026#34;mybatis-config.xml\u0026#34;);\rSqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();\rSqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is);\r//获取SqlSession\r SqlSession sqlSession = sqlSessionFactory.openSession();\r//调用MyBatis原生接口执行SQL\r //statement为UserMapper.xml的namespace值+\u0026#34;.\u0026#34;+select标签的id值\r String statement = \u0026#34;tech.langchao2020.mapper.UserMapper.findById\u0026#34;;\rUser user = sqlSession.selectOne(statement,1);\rSystem.out.println(user.toString());\r}\r}\r  查询的结果为：\n1  User{id=1, username=\u0026#39;浪花之颠\u0026#39;, password=\u0026#39;996.icu\u0026#39;, age=26}\r  注意！**，Idea集成开发环境不会编译src下的java目录下的xml文件的，所以找不到xml文件，因此需要在pom.xml配置相关build；\n1 2 3 4 5 6 7 8 9 10 11  \u0026lt;build\u0026gt;\r\u0026lt;resources\u0026gt;\r\u0026lt;resource\u0026gt;\r\u0026lt;directory\u0026gt;src/main/java\u0026lt;/directory\u0026gt;\r\u0026lt;includes\u0026gt;\r\u0026lt;include\u0026gt;**/*.xml\u0026lt;/include\u0026gt;\r\u0026lt;/includes\u0026gt;\r\u0026lt;/resource\u0026gt;\r\u0026lt;/resources\u0026gt;\r\u0026lt;/build\u0026gt;\r  2.使用Mapper代理实现自定义接口 步骤一：自定义接口，定义相关的业务方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  package tech.langchao2020.repository;\rimport tech.langchao2020.entity.User;\rimport java.util.List;\rpublic interface UserRepository {\r// 定义CRUD相关操作\r public int save(User user);\rpublic int update(User user);\rpublic int deleteById(int id);\rpublic List\u0026lt;User\u0026gt; findAll();\rpublic User findById(int id);\r}\r  步骤二：编写与方法相对应的Mapper.xml文件（其接口方法对应的SQL语句）\nstatement 标签可根据 SQL 执⾏行行的业务选择 insert、delete、update、select；\nMyBatis框架会自动根据规则自动创建接口实现类的代理对象，对应规则如下：\n Mapper.xml 中 namespace 为接口的全类名。 Mapper.xml 中 statement 的 id 为接口中对应的⽅方法名。 Mapper.xml 中 statement 的 parameterType 和接口中对应⽅方法的参数类型⼀一致。 Mapper.xml 中 statement 的 resultType 和接口中对应⽅方法的返回值类型一致。  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt;\r\u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt;\r\u0026lt;mapper namespace=\u0026#34;tech.langchao2020.repository.UserRepository\u0026#34;\u0026gt;\r\u0026lt;select id=\u0026#34;save\u0026#34; parameterType=\u0026#34;tech.langchao2020.entity.User\u0026#34; resultType=\u0026#34;int\u0026#34;\u0026gt;\rinsert into t_user (id, username, password, age) values (#{id}, #{username},#{password}, #{age})\r\u0026lt;/select\u0026gt;\r\u0026lt;update id=\u0026#34;update\u0026#34; parameterType=\u0026#34;tech.langchao2020.entity.User\u0026#34;\u0026gt;\rupdate t_user set username = #{username},password = #{password},age= #{age} where id = #{id}\r\u0026lt;/update\u0026gt;\r\u0026lt;delete id=\u0026#34;deleteById\u0026#34; parameterType=\u0026#34;int\u0026#34;\u0026gt;\rdelete from t_user where id = #{id}\r\u0026lt;/delete\u0026gt;\r\u0026lt;select id=\u0026#34;findAll\u0026#34; resultType=\u0026#34;tech.langchao2020.entity.User\u0026#34;\u0026gt;\rselect * from t_user\r\u0026lt;/select\u0026gt;\r\u0026lt;select id=\u0026#34;findById\u0026#34; parameterType=\u0026#34;int\u0026#34; resultType=\u0026#34;tech.langchao2020.entity.User\u0026#34;\u0026gt;\rselect * from t_user where id=#{id}\r\u0026lt;/select\u0026gt;\r\u0026lt;/mapper\u0026gt;\r  步骤三：在\\src\\main\\resources\\mybatis-config.xml配置文件中注册UserRepository.xml文件。\n1 2 3 4  \u0026lt;mappers\u0026gt;\r\u0026lt;mapper resource=\u0026#34;tech/langchao2020/repository/UserRepository.xml\u0026#34;/\u0026gt;\r\u0026lt;/mappers\u0026gt;\r  步骤四：在Test类中编写测试程序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  package tech.langchao2020.test;\rimport org.apache.ibatis.session.SqlSession;\rimport org.apache.ibatis.session.SqlSessionFactory;\rimport org.apache.ibatis.session.SqlSessionFactoryBuilder;\rimport tech.langchao2020.entity.User;\rimport tech.langchao2020.repository.UserRepository;\rimport java.io.InputStream;\rimport java.util.List;\rpublic class Test {\rpublic static void main(String[] args) {\r// 1.使用原生接口\r /*//加载MyBatis配置文件\rInputStream is = Test.class.getClassLoader().getResourceAsStream(\u0026#34;mybatis-config.xml\u0026#34;);\rSqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();\rSqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is);\r//获取SqlSession\rSqlSession sqlSession = sqlSessionFactory.openSession();\r//调用MyBatis原生接口执行SQL\r//statement为UserMapper.xml的namespace值+\u0026#34;.\u0026#34;+select标签的id值\rString insertSql = \u0026#34;tech.langchao2020.mapper.UserMapper.save\u0026#34;;\rUser user1 = new User(4, \u0026#34;狂野之裤\u0026#34;, \u0026#34;root666\u0026#34;, 21);\rsqlSession.insert(insertSql,user1);\rsqlSession.commit();\rString statement = \u0026#34;tech.langchao2020.mapper.UserMapper.findById\u0026#34;;\rUser user = sqlSession.selectOne(statement, 3);\rSystem.out.println(user.toString());*/\r// 2. 使用自定义接口\r InputStream is = Test.class.getClassLoader().getResourceAsStream(\u0026#34;mybatis-config.xml\u0026#34;);\rSqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();\rSqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is);\r//获取SqlSession\r SqlSession sqlSession = sqlSessionFactory.openSession();\r// 获取实现接口的代理对象\r UserRepository userRepository = sqlSession.getMapper(UserRepository.class);\ruserRepository.deleteById(3);\r// System.out.println(userRepository.findById(1).toString());\r List\u0026lt;User\u0026gt; list = userRepository.findAll();\rfor (User user:list) {\rSystem.out.println(user.toString());\r}\rsqlSession.commit();\rsqlSession.close();\r}\r}\r  程序输出结果为：\n1 2 3 4  User{id=1, username=\u0026#39;浪花之颠\u0026#39;, password=\u0026#39;996.icu\u0026#39;, age=26}\rUser{id=2, username=\u0026#39;飘过的野牛\u0026#39;, password=\u0026#39;root123\u0026#39;, age=17}\rUser{id=4, username=\u0026#39;狂野之裤\u0026#39;, password=\u0026#39;root666\u0026#39;, age=21}\r  4.Mapper.xml详解  statement标签：select、update、delete、insert 分别对应查询、修改、删除、添加操作。 parameterType：参数的数据类型（Java程序调用方法所提供的参数）    基本数据类型，通过 id 查询 User\n1 2 3 4  \u0026lt;select id=\u0026#34;findById\u0026#34; parameterType=\u0026#34;int\u0026#34; resultType=\u0026#34;tech.langchao2020.entity.User\u0026#34;\u0026gt;\rselect * from t_user where id=#{id}\r\u0026lt;/select\u0026gt;\r    String 类型，通过 username 查询 User\n1 2 3 4  \u0026lt;select id=\u0026#34;findByName\u0026#34; parameterType=\u0026#34;java.lang.String\u0026#34; resultType=\u0026#34;tech.langchao2020.entity.User\u0026#34;\u0026gt;\rselect * from t_user where username=#{username}\r\u0026lt;/select\u0026gt;\r    包装类，通过 id 查询 User\n1 2 3 4  \u0026lt;select id=\u0026#34;findById\u0026#34; parameterType=\u0026#34;java.lang.Integer\u0026#34; resultType=\u0026#34;tech.langchao2020.entity.User\u0026#34;\u0026gt;\rselect * from t_user where id=#{id}\r\u0026lt;/select\u0026gt;\r    多个参数，通过uesrname 和 age 查询 User\n1 2 3 4  \u0026lt;select id=\u0026#34;findByUsernameAndAge\u0026#34; resultType=\u0026#34;tech.langchao2020.entity.User\u0026#34;\u0026gt;\rselect * from t_user where username=#{arg0} and age=#{arg1}\r\u0026lt;/select\u0026gt;\r    Java Bean\n1 2 3 4 5  \u0026lt;update id=\u0026#34;update\u0026#34; parameterType=\u0026#34;tech.langchao2020.entity.User\u0026#34;\u0026gt;\rupdate t_user set username = #{username},password = #{password},age =\r#{age} where id = #{id}\r\u0026lt;/update\u0026gt;\r     resultType：结果类型    基本数据类型，统计 User 总数\n1 2 3 4  \u0026lt;select id=\u0026#34;count\u0026#34; resultType=\u0026#34;int\u0026#34;\u0026gt;\rselect count(id) from t_user\r\u0026lt;/select\u0026gt;\r    包装类，统计 User 总数\n1 2 3 4  \u0026lt;select id=\u0026#34;count\u0026#34; resultType=\u0026#34;java.lang.Integer\u0026#34;\u0026gt;\rselect count(id) from t_user\r\u0026lt;/select\u0026gt;\r    String 类型，通过 id 查询 User 的 username\n1 2 3 4  \u0026lt;select id=\u0026#34;findNameById\u0026#34; resultType=\u0026#34;java.lang.String\u0026#34;\u0026gt;\rselect username from t_user where id=#{id}\r\u0026lt;/select\u0026gt;\r    Java Bean\n1 2 3 4  \u0026lt;select id=\u0026#34;findById\u0026#34; parameterType=\u0026#34;int\u0026#34; resultType=\u0026#34;tech.langchao2020.entity.User\u0026#34;\u0026gt;\rselect * from t_user where id=#{id}\r\u0026lt;/select\u0026gt;\r    5.级联查询  一对多 多对多  6.逆向工程 MyBatis Generator，简称MBG，是⼀一个专⻔门为 MyBatis 框架开发者定制的代码⽣生成器器，可自动⽣生成\nMyBatis 框架所需的实体类、Mapper 接口、Mapper.xml，⽀支持基本的 CRUD 操作，但是⼀些相对复杂的 SQL 需要开发者自己来完成。\n如何使用逆向工程？ 步骤1：新建Maven工程，添加相关的依赖\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  \u0026lt;dependencies\u0026gt;\r\u0026lt;dependency\u0026gt;\r\u0026lt;groupId\u0026gt;org.mybatis\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;mybatis\u0026lt;/artifactId\u0026gt;\r\u0026lt;version\u0026gt;3.4.5\u0026lt;/version\u0026gt;\r\u0026lt;/dependency\u0026gt;\r\u0026lt;dependency\u0026gt;\r\u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt;\r\u0026lt;version\u0026gt;8.0.11\u0026lt;/version\u0026gt;\r\u0026lt;/dependency\u0026gt;\r\u0026lt;dependency\u0026gt;\r\u0026lt;groupId\u0026gt;org.mybatis.generator\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;mybatis-generator-core\u0026lt;/artifactId\u0026gt;\r\u0026lt;version\u0026gt;1.3.2\u0026lt;/version\u0026gt;\r\u0026lt;/dependency\u0026gt;\r\u0026lt;/dependencies\u0026gt;\r  步骤2：创建MBG配置文件，src/resource/generatorConfig.xml\n jdbcConnection 配置数据库连接信息。 javaModelGenerator 配置 JavaBean 的生成策略。 sqlMapGenerator 配置 SQL 映射⽂文件生成策略。 javaClientGenerator 配置 Mapper 接口的生成策略. table 配置目标数据表（tableName：表名，domainObjectName：JavaBean 类(实体类)名）。  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt;\r\u0026lt;!DOCTYPE generatorConfiguration PUBLIC \u0026#34;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\u0026#34;\r\u0026#34;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\u0026#34;\u0026gt;\r\u0026lt;generatorConfiguration\u0026gt;\r\u0026lt;context id=\u0026#34;testTables\u0026#34; targetRuntime=\u0026#34;MyBatis3\u0026#34;\u0026gt;\r\u0026lt;jdbcConnection driverClass=\u0026#34;com.mysql.cj.jdbc.Driver\u0026#34;\rconnectionURL=\u0026#34;jdbc:mysql://120.24.207.216:3306/mybatis?useUnicode=true\u0026amp;amp;characterEncoding=UTF-8\u0026#34;\ruserId=\u0026#34;root\u0026#34; password=\u0026#34;xxxxx\u0026#34;/\u0026gt;\r\u0026lt;javaModelGenerator targetPackage=\u0026#34;tech.langchao2020.entity\u0026#34; targetProject=\u0026#34;./src/main/java\u0026#34;/\u0026gt;\r\u0026lt;sqlMapGenerator targetPackage=\u0026#34;tech.langchao2020.repository\u0026#34; targetProject=\u0026#34;./src/main/java\u0026#34;/\u0026gt;\r\u0026lt;javaClientGenerator type=\u0026#34;XMLMAPPER\u0026#34; targetPackage=\u0026#34;tech.langchao2020.repository\u0026#34;\rtargetProject=\u0026#34;./src/main/java\u0026#34;\u0026gt;\u0026lt;/javaClientGenerator\u0026gt;\r\u0026lt;table tableName=\u0026#34;t_user\u0026#34; domainObjectName=\u0026#34;User\u0026#34;/\u0026gt;\r\u0026lt;/context\u0026gt;\r\u0026lt;/generatorConfiguration\u0026gt;\r  步骤3：创建Test程序测试\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51  package tech.langchao2020.test;\rimport org.mybatis.generator.api.MyBatisGenerator;\rimport org.mybatis.generator.config.Configuration;\rimport org.mybatis.generator.config.xml.ConfigurationParser;\rimport org.mybatis.generator.exception.InvalidConfigurationException;\rimport org.mybatis.generator.exception.XMLParserException;\rimport org.mybatis.generator.internal.DefaultShellCallback;\rimport java.io.File;\rimport java.io.IOException;\rimport java.sql.SQLException;\rimport java.util.ArrayList;\rimport java.util.List;\rpublic class Test {\rpublic static void main(String[] args) {\rList\u0026lt;String\u0026gt; warings = new ArrayList\u0026lt;String\u0026gt;();\rboolean overwrite = true;\rString genCig = \u0026#34;/generatorConfig.xml\u0026#34;;\rFile configFile = new File(Test.class.getResource(genCig).getFile());\rConfigurationParser configurationParser = new\rConfigurationParser(warings);\rConfiguration configuration = null;\rtry {\rconfiguration = configurationParser.parseConfiguration(configFile);\r} catch (IOException e) {\re.printStackTrace();\r} catch (XMLParserException e) {\re.printStackTrace();\r}\rDefaultShellCallback callback = new DefaultShellCallback(overwrite);\rMyBatisGenerator myBatisGenerator = null;\rtry {\rmyBatisGenerator = new\rMyBatisGenerator(configuration, callback, warings);\r} catch (InvalidConfigurationException e) {\re.printStackTrace();\r}\rtry {\rmyBatisGenerator.generate(null);\r} catch (SQLException e) {\re.printStackTrace();\r} catch (IOException e) {\re.printStackTrace();\r} catch (InterruptedException e) {\re.printStackTrace();\r}\r}\r}\r  7.延迟加载 8.缓存 9.动态SQL (7、8、9条日后有空填坑。)\n","description":"今天还是学的MyBatis框架，主要是学习了如何使用Mapper代理实现自定义接口以及逆向工程。","id":2,"section":"posts","tags":["JavaWeb",""],"title":"4.28_MyBatis（补充版）","uri":"http://think.pengchangwen.site/posts/mybatis-02/"},{"content":"★MyBatis基础 1.什么是MyBatis？ MyBatis是一个实现了数据持久化的开源框架，这句话的终点是数据持久化。问题来了，什么是数据持久化呢？百度百科给出的解释是：\n “数据持久化就是将内存中的数据模型转换为存储模型，以及将存储模型转换为内存中的数据模型的统称。 数据模型可以是任何数据结构或对象模型,存储模型可以是关系模型、XML、二进制流等。”\n 但是对于现阶段的我这个菜鸟俩说，只需要记得数据持久化就是把数据存到数据库中即可（Java对象模型和关系模型之间的对应）。\n2.如何使用MyBatis？(准备阶段)   创建Maven工程，配置pom.xml相关的依赖\n1 2 3 4 5 6 7 8 9 10 11  \u0026lt;dependency\u0026gt;\r\u0026lt;groupId\u0026gt;org.mybatis\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;mybatis\u0026lt;/artifactId\u0026gt;\r\u0026lt;version\u0026gt;3.5.4\u0026lt;/version\u0026gt;\r\u0026lt;/dependency\u0026gt;\r\u0026lt;dependency\u0026gt;\r\u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt;\r\u0026lt;version\u0026gt;8.0.18\u0026lt;/version\u0026gt;\r\u0026lt;/dependency\u0026gt;\r    在mybatis数据库中新建数据表\n1 2 3 4 5 6  create table t_user(\rid int primary key auto_increment,\rusername varchar(11),\rpassword varchar(11),\rage int\r)\r    在Java代码中创建数据表t_user对应的实体类tech.langchao2020.entity.User\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  public class User {\rprivate int id;\rprivate String username;\rprivate String password;\rprivate int age;\rpublic int getId() {\rreturn id;\r}\rpublic void setId(int id) {\rthis.id = id;\r}\rpublic String getUsername() {\rreturn username;\r}\rpublic void setUsername(String username) {\rthis.username = username;\r}\rpublic String getPassword() {\rreturn password;\r}\rpublic void setPassword(String password) {\rthis.password = password;\r}\rpublic int getAge() {\rreturn age;\r}\rpublic void setAge(int age) {\rthis.age = age;\r}\r@Override\rpublic String toString() {\rreturn \u0026#34;User{\u0026#34; +\r\u0026#34;id=\u0026#34; + id +\r\u0026#34;, username=\u0026#39;\u0026#34; + username + \u0026#39;\\\u0026#39;\u0026#39; +\r\u0026#34;, password=\u0026#39;\u0026#34; + password + \u0026#39;\\\u0026#39;\u0026#39; +\r\u0026#34;, age=\u0026#34; + age +\r\u0026#39;}\u0026#39;;\r}\r}\r    添加MyBatis配置文件\\src\\main\\resources\\mybatis-config.xml文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt;\r\u0026lt;!DOCTYPE configuration PUBLIC \u0026#34;-//mybatis.org//DTD Config 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-config.dtd\u0026#34;\u0026gt;\r\u0026lt;configuration\u0026gt;\r\u0026lt;!--配置MyBatis运行环境 --\u0026gt;\r\u0026lt;environments default=\u0026#34;development\u0026#34;\u0026gt;\r\u0026lt;environment id=\u0026#34;development\u0026#34;\u0026gt;\r\u0026lt;!--配置JDBC事务管理 --\u0026gt;\r\u0026lt;transactionManager type=\u0026#34;JDBC\u0026#34;/\u0026gt;\r\u0026lt;!--POOLED配置JDBC数据源连接池 --\u0026gt;\r\u0026lt;dataSource type=\u0026#34;POOLED\u0026#34;\u0026gt;\r\u0026lt;property name=\u0026#34;driver\u0026#34; value=\u0026#34;com.mysql.cj.jdbc.Driver\u0026#34;/\u0026gt;\r\u0026lt;property name=\u0026#34;url\u0026#34;\rvalue=\u0026#34;jdbc:mysql://120.24.207.216:3306/mybatis?useUnicode=true\u0026amp;amp;characterEncoding=UTF-8\u0026#34;/\u0026gt;\r\u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt;\r\u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;xxxxx\u0026#34;/\u0026gt;\r\u0026lt;/dataSource\u0026gt;\r\u0026lt;/environment\u0026gt;\r\u0026lt;/environments\u0026gt;\r\u0026lt;/configuration\u0026gt;\r    3.MyBatis开发的两种方式  使用原生接口 使用Mapper代理实现自定义接口  1.使用原生接口开发 步骤1：在tech.langchao2020.mapper下创建UserMapper.xml文件；namespace通常设置为文件所在包名+文件名，parameterType为参数数据类型，resultType为返回值数据类型。\n1 2 3 4 5 6 7 8 9  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt;\r\u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt;\r\u0026lt;mapper namespace=\u0026#34;com.southwind.mapper.UserMapper\u0026#34;\u0026gt;\r\u0026lt;select id=\u0026#34;get\u0026#34; parameterType=\u0026#34;int\u0026#34; resultType=\u0026#34;tech.langchao2020.entity.User\u0026#34;\u0026gt;\rselect * from user where id=#{id}\r\u0026lt;/select\u0026gt;\r\u0026lt;/mapper\u0026gt;\r  步骤2：在\\src\\main\\resources\\mybatis-config.xml配置文件中注册UseMapper.xml`文件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt;\r\u0026lt;!DOCTYPE configuration PUBLIC \u0026#34;-//mybatis.org//DTD Config 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-config.dtd\u0026#34;\u0026gt;\r\u0026lt;configuration\u0026gt;\r\u0026lt;!--配置MyBatis运行环境 --\u0026gt;\r\u0026lt;environments default=\u0026#34;development\u0026#34;\u0026gt;\r\u0026lt;environment id=\u0026#34;development\u0026#34;\u0026gt;\r\u0026lt;!--配置JDBC事务管理 --\u0026gt;\r\u0026lt;transactionManager type=\u0026#34;JDBC\u0026#34;/\u0026gt;\r\u0026lt;!--POOLED配置JDBC数据源连接池 --\u0026gt;\r\u0026lt;dataSource type=\u0026#34;POOLED\u0026#34;\u0026gt;\r\u0026lt;property name=\u0026#34;driver\u0026#34; value=\u0026#34;com.mysql.cj.jdbc.Driver\u0026#34;/\u0026gt;\r\u0026lt;property name=\u0026#34;url\u0026#34;\rvalue=\u0026#34;jdbc:mysql://120.24.207.216:3306/mybatis?useUnicode=true\u0026amp;amp;characterEncoding=UTF-8\u0026#34;/\u0026gt;\r\u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt;\r\u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;xxxxx\u0026#34;/\u0026gt;\r\u0026lt;/dataSource\u0026gt;\r\u0026lt;/environment\u0026gt;\r\u0026lt;/environments\u0026gt;\r\u0026lt;mappers\u0026gt;\r\u0026lt;mapper resource=\u0026#34;tech/langchao2020/mapper/UserMapper.xml\u0026#34;/\u0026gt;\r\u0026lt;/mappers\u0026gt;\r\u0026lt;/configuration\u0026gt;\r  步骤3，在tech.langchao2020.test创建Test类测试。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  package tech.langchao2020.test;\rimport org.apache.ibatis.session.SqlSession;\rimport org.apache.ibatis.session.SqlSessionFactory;\rimport org.apache.ibatis.session.SqlSessionFactoryBuilder;\rimport tech.langchao2020.entity.User;\rimport java.io.InputStream;\rpublic class Test {\rpublic static void main(String[] args) {\r//加载MyBatis配置文件\r InputStream is = Test.class.getClassLoader().getResourceAsStream(\u0026#34;mybatis-config.xml\u0026#34;);\rSqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();\rSqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is);\r//获取SqlSession\r SqlSession sqlSession = sqlSessionFactory.openSession();\r//调用MyBatis原生接口执行SQL\r //statement为UserMapper.xml的namespace值+\u0026#34;.\u0026#34;+select标签的id值\r String statement = \u0026#34;tech.langchao2020.mapper.UserMapper.findById\u0026#34;;\rUser user = sqlSession.selectOne(statement,1);\rSystem.out.println(user.toString());\r}\r}\r  查询的结果为：\n1  User{id=1, username=\u0026#39;浪花之颠\u0026#39;, password=\u0026#39;996.icu\u0026#39;, age=26}\r  注意！**，Idea集成开发环境不会编译src下的java目录下的xml文件的，所以找不到xml文件，因此需要在pom.xml配置相关build；\n1 2 3 4 5 6 7 8 9 10  \u0026lt;build\u0026gt;\r\u0026lt;resources\u0026gt;\r\u0026lt;resource\u0026gt;\r\u0026lt;directory\u0026gt;src/main/java\u0026lt;/directory\u0026gt;\r\u0026lt;includes\u0026gt;\r\u0026lt;include\u0026gt;**/*.xml\u0026lt;/include\u0026gt;\r\u0026lt;/includes\u0026gt;\r\u0026lt;/resource\u0026gt;\r\u0026lt;/resources\u0026gt;\r\u0026lt;/build\u0026gt;\r  4.使用Mapper代理实现自定义接口 ","description":"今日学习了一点点MyBatis的相关知识，仅限于如何使用等最基本的操作。关于前几天的图书管理Java Web项目想停下来思考会儿，于是转来学习MyBatis了，算是给自己调剂调剂口味...","id":3,"section":"posts","tags":["JavaWeb",""],"title":"4.27_Mybatis基础学习","uri":"http://think.pengchangwen.site/posts/mybatis-study/"},{"content":"★MVC开发模式 MVC是将程序分层的一种开发思想。\n  M：Model\t业务数据（service、repository、entity）\n  V：View\t试图（JSP、HTML、客户端等）\n  C：Controller\t控制（Servlet、Handler、Action）\n  请求进入Java Web应用后，Controller接收到该请求，进行业务逻辑的处理，最终将处理的结果（View+Model）再返回给用户；\n请求进入Controller，调用Service进行业务处理，从Controller中将Model数据带到View中并响应给用户；\nController\t\u0026ndash;\u0026gt;\tService\t\u0026ndash;\u0026gt;\trepository。\n★登录功能 ◇1.读者登录  在reader表中查询该读者账号密码是否正确，如果正确则跳转读者首页，失败则重定向到登录页面；  ◇2.管理员登录  在bookadmin表中查询该读者账号密码是否正确，如果正确则跳转读者首页，失败则重定向到登录页面；  ★分页功能 ","description":"打算找两个Java项目做，第一个是JSP版本的，用来巩固最近学的Java Web基础。另一个是SSM版的，用来巩固上周学习的Spring、Spring MVC以及MyBatis。总感觉自己还没有全力以赴，时间管理上还是很有欠缺，每天可供利用的有效时间很少很少...","id":4,"section":"posts","tags":["",""],"title":"4.26_基础版图书管理系统(使用最纯粹的Java Web开发方式)","uri":"http://think.pengchangwen.site/posts/book-manage-system/"},{"content":"★JSTL详解 JSP标准标签库，JSP为开发者提供的一些列的标签；使用这些标签可以完成一些逻辑处理，比如循环遍历集合，让代码更加简洁，不会再出现JSP脚本穿插的情况；算是在EL表达式上又再一次简化了JSP的开发。\n实际开发中EL表达式和JSTL结合使用，EL通常用来展示数据，逻辑处理用JSTL；\nJSTL的使用   导入jstl.jar和standard.jar包，放在WEB-INF/lib下\n  在JSP页面开始的地方导入JSPL标签库\n1  \u0026lt;%@ taglib prefix=\u0026#34;c\u0026#34; uri=\u0026#34;http://java.sun.com/jsp/jstl/core\u0026#34; %\u0026gt;     使用\n\u0026lt;c:forEach items=\u0026quot;${list}\u0026quot; var=\u0026quot;user\u0026quot;\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;${user.id}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;${user.name}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;${user.score}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;${user.address.value}\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/c:forEach\u0026gt;   JSTL优点  提供了统一的标签 可以编写各种动态功能  JSTL常用标签 set、out、remove、catch\n  set 向域对象中添加数据\n\u0026lt;c:set var=\u0026quot;name\u0026quot; scope=\u0026quot;request\u0026quot; value=\u0026quot;langchao\u0026quot;\u0026gt;\u0026lt;/c:set\u0026gt; ${requestScope.name}   out 输出域对象中的数据（如果属性不存在时可以默认输出）\n\u0026lt;c:set var=\u0026quot;name\u0026quot; scope=\u0026quot;request\u0026quot; value=\u0026quot;langchao\u0026quot;\u0026gt;\u0026lt;/c:set\u0026gt; \u0026lt;c:out value=\u0026quot;${name}\u0026quot; default=\u0026quot;未定义\u0026quot;\u0026gt;\u0026lt;/c:out\u0026gt;   remove 移除域对象中的数据\n\u0026lt;c:remove var=\u0026quot;name\u0026quot; scope=\u0026quot;page\u0026quot;\u0026gt;\u0026lt;/c:set\u0026gt; \u0026lt;c:out value=\u0026quot;${name}\u0026quot; default=\u0026quot;未定义\u0026quot;\u0026gt;\u0026lt;/c:out\u0026gt;   catch 处理异常信息\n\u0026lt;c:catch var=\u0026quot;error\u0026quot;\u0026gt; \u0026lt;% int a = 10 / 0; %\u0026gt; \u0026lt;/c:catch\u0026gt; ${error}   ★JDBC JDBC是什么？ Java DataBase Connectivity是一个独立于特定数据库的管理系统，是通用的SQL数据库存取和操作的公共接口；定义了一组标准，为访问不同的数据库提供了统一的途径；\nJDBC体系结构  面向应用的API（供开发者调用） 面向数据库API（供数据库厂商开发驱动程序）   JDBC API 提供者: Java 官方\n内容:供开发者调用的接口\njava.sq| 和javax.sql\n DriverManager 类 Connection 接口 Statement 接口 ResultSet 接口  DriverManager 提供者: Java官方\n作用：管理不同的JDBC驱动（比如MySQL、Oracle、Redis等）\nJDBC驱动\n提供者：数据库厂商\n作用：负责连接不同的数据库\nJDBC的使用  加载数据库驱动，该驱动是Java程序和数据库之间的桥梁； 获取Connection，表示Java程序与数据库的一次连接； 创建Statement对象，由Connection产生，用来执行SQL语句； 如果需要接受返回值，则创建ResulSet对象，保存Statement执行之后所查询到的结果；  增删改用的是statement对象的executeUpdate方法，查询使用的是executeQuery方法；\n案例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  try { // 1、加载数据库驱动(通过反射加载)  Class.forName(\u0026#34;com.mysql.cj.jdbc.Driver\u0026#34;); // 2、获取连接  String url = \u0026#34;jdbc:mysql://localhost:3306/library?useUnicode=true\u0026amp;characterEncoding=UTF-8\u0026#34;; String user = \u0026#34;root\u0026#34;; String password = \u0026#34;123123\u0026#34;; Connection connection = DriverManager.getConnection(url, user, password); // System.out.println(connection);  // 3、创建相关的SQL语句,并使用statement对象的相关方法执行  String sql = \u0026#34;INSERT INTO book(name, author, publish) values(\u0026#39;算法导论\u0026#39;,\u0026#39;大牛\u0026#39;,\u0026#39;机械工业出版社\u0026#39;)\u0026#34;; // String sql = \u0026#34;UPDATE book SET author=\u0026#39;路过的萌牛\u0026#39;\u0026#34;;  Statement statement = connection.createStatement(); statement.executeUpdate(sql); // 使用PreparedStatement(Statement的子类),其提供了占位符功能  String find = \u0026#34;SELECT * FROM book WHERE publish = ?\u0026#34;; String publishTest = \u0026#34;三联出版社\u0026#34;; PreparedStatement preparedStatement = connection.prepareStatement(find); preparedStatement.setString(1, publishTest); ResultSet resultSet = preparedStatement.executeQuery(); // 拿出Result中的数据  while (resultSet.next()) { int id = resultSet.getInt(\u0026#34;id\u0026#34;); String name = resultSet.getString(2); String author = resultSet.getString(\u0026#34;author\u0026#34;); String publish = resultSet.getString(4); System.out.println(id + \u0026#34;\\t\u0026#34; + name + \u0026#34;\\t\u0026#34; + author + \u0026#34;\\t\u0026#34; + publish); } } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (SQLException e) { e.printStackTrace(); }   从数据库中取出的数据如下：\n1 2 3 4  11\t水浒传\t路过的萌牛\t三联出版社 12\t三国演义\t路过的萌牛\t三联出版社 13\t红楼梦\t路过的萌牛\t三联出版社 14\t西游记\t路过的萌牛\t三联出版社     开发中使用PreparedStatement（是Statement的子类）\n 提供了SQL占位符的功能\n   使用Statement进行开发的两大问题\n 需要频繁拼接String字符串，出错率较高 存在SQL注入风险    ★Web综合案例 ◇1.测试数据库是否连接成功 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  /** * 测试是否能够成功连接数据库 * 1.加载驱动 * 2.创建连接 * 3.PreparedStatement执行相关语句 */ public class Test { public static void main(String[] args) { try { Class.forName(\u0026#34;com.mysql.cj.jdbc.Driver\u0026#34;); String url = \u0026#34;jdbc:mysql://127.0.0.1:3306/library?useUnicode=true\u0026amp;characterEncoding=UTF-8\u0026#34;; String user = \u0026#34;root\u0026#34;; String password = \u0026#34;root123456\u0026#34;; Connection connection = DriverManager.getConnection(url, user, password); String sql = \u0026#34;SELECT * FROM book WHERE publish = ?\u0026#34;; PreparedStatement preparedStatement = connection.prepareStatement(sql); preparedStatement.setString(1, \u0026#34;三联出版社\u0026#34;); // 获取查询结果  ResultSet resultSet = preparedStatement.executeQuery(); while (resultSet.next()) { Integer id = resultSet.getInt(1); String name = resultSet.getString(\u0026#34;name\u0026#34;); String publish = resultSet.getString(\u0026#34;publish\u0026#34;); System.out.println(id + \u0026#34;-\u0026#34; + name + \u0026#34;-\u0026#34; + publish); } } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (SQLException e) { e.printStackTrace(); } } }   ◇2.实现增删改查操作   Servlet+JSP+JDBC\n  使用过滤器Filter处理中文乱码问题\n  数据库的连接封装成JDBCTools类\n  ★数据库连接池C3P0 ◇1.C3P0概述 C3P0是为优化Java程序连接（Connection）数据库而产生，传统JDBC操作数据库（如执行一次查询操作就需要拿到一个connection对象（由DriverManger产生），但是查询完了之后就释放掉了，资源没有得到很好的利用）。如果放大操作次数，比如查询5000次，就得产生5000个连接并且每次用完就得释放掉。于是C3P0应运而生，它是一个数据库连接池，提前将若干个连接放到数据库连接池，Java程序需要用到的时候直接从数据库连接池中取，用完之后也不释放，继续还到连接池中，连接资源得到了很好的复用。\n◇2.使用C3P0的两种方式   在Java程序中使用(需要引入c3p0第三方包)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  // 创建C3P0 ComboPooledDataSource dataSource = new ComboPooledDataSource(); try { dataSource.setDriverClass(\u0026#34;com.mysql.cj.jdbc.Driver\u0026#34;); dataSource.setJdbcUrl(\u0026#34;jdbc:mysql://localhost:3306/library?useUnicode=true\u0026amp;character=UTF-8\u0026#34;); dataSource.setUser(\u0026#34;root\u0026#34;); dataSource.setPassword(\u0026#34;root123456\u0026#34;); // 获取连接  Connection connection = dataSource.getConnection(); // 设置若干连接池配置信息....  // 若干操作....  String sql = \u0026#34;SELECT * FROM book WHERE publish = ?\u0026#34;; PreparedStatement preparedStatement = connection.prepareStatement(sql); preparedStatement.setString(1, \u0026#34;三联出版社\u0026#34;); // 获取查询结果  ResultSet resultSet = preparedStatement.executeQuery(); while (resultSet.next()) { Integer id = resultSet.getInt(1); String name = resultSet.getString(\u0026#34;name\u0026#34;); String publish = resultSet.getString(\u0026#34;publish\u0026#34;); System.out.println(id + \u0026#34;-\u0026#34; + name + \u0026#34;-\u0026#34; + publish); } // 还回到数据库连接池中  connection.close(); } catch (PropertyVetoException e) { e.printStackTrace(); } catch (SQLException e) { e.printStackTrace(); }     在c3p0-config.xml文件中配置数据库连接池的相关信息(配置文件名必须是c3p0-config.xml且必须是在src根目录下)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  \u0026lt;c3p0-config\u0026gt; \u0026lt;named-config name=\u0026#34;otherc3p0\u0026#34;\u0026gt; \u0026lt;!--连接参数 --\u0026gt; \u0026lt;property name=\u0026#34;driverClass\u0026#34;\u0026gt;com.mysql.cj.jdbc.Driver\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;jdbcUrl\u0026#34;\u0026gt;jdbc:mysql://localhost:3306/library?useUnicode=true\u0026amp;amp;character=UTF-8\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;user\u0026#34;\u0026gt;root\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34;\u0026gt;root123456\u0026lt;/property\u0026gt; \u0026lt;!--连接池参数 --\u0026gt; \u0026lt;property name=\u0026#34;initialPoolSize\u0026#34;\u0026gt;5\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;maxPoolSize\u0026#34;\u0026gt;8\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;checkoutTimeout\u0026#34;\u0026gt;1000\u0026lt;/property\u0026gt; \u0026lt;/named-config\u0026gt; \u0026lt;/c3p0-config\u0026gt;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  // 创建C3P0 (otherc3p0对应c3p0-config.xml文件中的name属性值) ComboPooledDataSource dataSource = new ComboPooledDataSource(\u0026#34;otherc3p0\u0026#34;); try { // 获取连接  Connection connection = dataSource.getConnection(); // 若干操作....  String sql = \u0026#34;SELECT * FROM book WHERE publish = ?\u0026#34;; PreparedStatement preparedStatement = connection.prepareStatement(sql); preparedStatement.setString(1, \u0026#34;三联出版社\u0026#34;); // 获取查询结果  ResultSet resultSet = preparedStatement.executeQuery(); while (resultSet.next()) { Integer id = resultSet.getInt(1); String name = resultSet.getString(\u0026#34;name\u0026#34;); String publish = resultSet.getString(\u0026#34;publish\u0026#34;); System.out.println(id + \u0026#34;-\u0026#34; + name + \u0026#34;-\u0026#34; + publish); } // 还回到数据库连接池中  connection.close(); } catch (SQLException e) { e.printStackTrace(); }     ★Windows10安装Ubuntu18.04 LTS子系统 1.如何安装Linux子系统 2.安装成功后相应的设置  设置root密码 更换国内阿里软件源 更新系统 安装并启用ssh服务 安装MySQL等常用软件 配置IP地址  ","description":"今天主要学习的是JSTL标签库和JDBC相关知识。正如昨天所说，肯定会有更好的东西取代EL表达式的，JSTL就是如此。JDBC提供了一组标准接口去访问数据库，C3P0对数据库连接做了优化，由此而来数据库连接池...","id":5,"section":"posts","tags":["JavaWeb",""],"title":"4.25_JSTL和JDBC的学习","uri":"http://think.pengchangwen.site/posts/jstl-jdbc-study/"},{"content":"★HTTP请求状态码  200 正常 404 资源找不到 400 请求类型不匹配 500 Java程序抛出异常  response常用方法 转发 getRequestDispatcher 和重定向 sendRedirect 的区别\n转发是指将同一个请求传给下一个页面，重定向是创建新的请求（客户端重新请求）传给下一个页面，之前的请求结束生命周期；\n转发：同一个请求在服务器内部传递，浏览器地址栏不变，也叫做服务器跳转；\n重定向：由客户端发送新的请求，访问跳转后的新的资源，浏览器地址栏改变，也叫客户端跳转；\n如果服务器两个页面之间需要通过request传值，则必须使用转发，不能使用重定向；\n sendRedirect(String path) 重定向，完成页面之间的跳转 使用转发和重定向完成一个登录的demo，如果用户名和密码有一个不对，就重定向到登录页面，如果都正确就返回欢迎页面，并带上用户名；  ★Session和Cookie 服务器无法识别http请求来自哪个终端，只会接收到请求信号，http是无状态协议。因此就产生了会话技术，session就是其中的一种技术；\n会话：客户端和服务器之间发生的一系列连续的请求和响应的过程；\n会话状态：服务器和浏览器在会话过程中产生的状态信息\n实现会话的两种方式：\n session cookie（作用在客户端，如浏览器）  属于同一个会话的请求都有同一个请求标识符——sessionID；\n1  String sessionId = seesion.getId(); // 获取会话的id   session常用方法  String getId()\t获取sessionID void setMaxInactiveInterval() 设置session的失效时间，单位为秒 int getMaxInactiveInterval() 获取当前session的失效时间 void invalidate() 设置session立即失效 void setAttribute() 通过键值对存储数据 通过key获取对应的value值 void removeAttribute(String name) 通过key删除对应的value值  使用session完成一个登录跳转页面；\nCookie 创建cookie\n1 2 3  // 创建cookie并响应到客户端 Cookie cookie = new Cookie(\u0026#34;name\u0026#34;, \u0026#34;langchao\u0026#34;); response.addCookie(cookie);   读取cookie\n1 2 3 4 5  Cookie[] cookies = request.getCookies(); for (Cookie cookie:cookies) { // out.write(cookie.toString());  out.write(cookie.getName()+\u0026#34;:\u0026#34;+cookie.getValue() + \u0026#34;\u0026lt;br /\u0026gt;\u0026#34;); }   Cookie常用方法    方法名 描述     setMaxAge(int age) 设置Cookie的有效时间，单位为秒   getMaxAge(int age) 获取Cookie的有效时间，单位为秒   getName() 获取Cookie的name   getValue() 获取Cookie的value    Session 和 Cookie的区别 session：保存在服务器（jvm中），保存的类型是Object类型，会随着会话的结束而销毁，保存重要信息（如账户和密码）；\ncookie：保存在浏览器中，保存的数据是String类型，可以长期保存在浏览器汇总，与会话无关；保存并不是很重要的信息（如你在网站观看视频的进度信息）；\n使用cookie完成一个登录跳转页面；\n存储用户信息：\nsession：setAttribute(name, \u0026ldquo;admin\u0026rdquo;) 存\ngetAttribute(name) 取\n退出登录：session.invalidate()\n生命周期：Web服务器一关闭/重启就被销毁，客户端一关闭也会被销毁；\ncookie：response.addCookie(name, \u0026ldquo;admin\u0026rdquo;) 存\n1 2 3 4 5 6 7  // 取到cookie Cookie[] cookies = request.getCookies(); for (Cookie cookie:cookies) { if (cookie.getName().equals(\u0026#34;name\u0026#34;)) { out.write(\u0026#34;Welcome\u0026#34; + cookie.getValue()); } }   生命周期：不随服务端的重启而销毁，客户端默认是关闭就被销毁，但是可以通过setMaxAge()方法设置有效期，销毁由设置的时间来决定；\n退出登录：setMaxAge(0)\n★JSP内置对象的作用域 下面四个内置对象都具备setAttribute和getAttribute方法，所以才讨论其作用域。（传输数据，考虑能不能拿到数据）\n  page，page只在当前页面有效\n page作用域：对应的内置对象是 pageContext\n   request，在一次请求内有效\n request作用域：对应的内置对象是 request\n   session，在一次会话内有效\n session作用域：对应的内置对象是 session\n   application，作用整个WEB应用\n application作用域：对应的内置对象是 application\n   作用域的大小：page \u0026lt; request \u0026lt; session \u0026lt; application\ndemo：写一个网站访问量统计程序；\n1 2 3 4 5 6 7 8 9 10 11  \u0026lt;% Integer count = (Integer) application.getAttribute(\u0026#34;count\u0026#34;); if (count == null) { count = 1; application.setAttribute(\u0026#34;count\u0026#34;, count); } else { count++; application.setAttribute(\u0026#34;count\u0026#34;, count); } %\u0026gt; 您当前是第\u0026lt;%=count%\u0026gt;位访客！   ★EL表达式 Expression Language（EL）表达式语言，可以替代JSP页面中数据访问时的复杂编码，为简化JSP页面而生；语法是：${变量名}；可以方便的从域对象（page、request、session、application）中保存的数据，前提是需要先setAttribute；(EL表达式只能在JSP中使用，HTML和Servlet中都无法使用；)\n为什么说是简化了JSP页面呢？看一个例子就知道；\n比如el.jsp页面中需要向el2.jsp页面中传递一个name的变量，所以应该是这样写：\nel.jsp\n1 2 3 4 5  \u0026lt;% String name = \u0026#34;langchao\u0026#34;; request.setAttribute(\u0026#34;name\u0026#34;, name); request.getRequestDispatcher(\u0026#34;el2.jsp\u0026#34;).forward(request,response); %\u0026gt;   el2.jsp取到name\n1 2 3 4  \u0026lt;% String name = (String) request.getAttribute(\u0026#34;name\u0026#34;); %\u0026gt; el.jsp中传递过来的name为：\u0026lt;%=name%\u0026gt;   用EL表达式简化后的写法：\n1  el.jsp中传递过来的name为：${name}   那问题来了，如果四个域对象都设置了同一个属性值（比如name），EL表达式该如何取呢？\n答：EL表达式查找顺序是：page-》request-》session》application\n问题又来了，如果就要取来自session中的属性值呢？\n答：${sessionScope.name}\n1 2 3 4 5 6 7  \u0026lt;% pageContext.setAttribute(\u0026#34;name\u0026#34;, \u0026#34;page\u0026#34;); request.setAttribute(\u0026#34;name\u0026#34;, \u0026#34;request\u0026#34;); session.setAttribute(\u0026#34;name\u0026#34;, \u0026#34;session\u0026#34;); application.setAttribute(\u0026#34;name\u0026#34;, \u0026#34;application\u0026#34;); %\u0026gt; ${sessionScope.name}   还可以很方便的取出对象的属性值；\n${user} ${user.id}或者${user[\u0026quot;id\u0026quot;]} ${user.name} ${user.address}  ${user.id}实际上是通过调用User类的getId()方法得到id的值；\n EL可以执行表达式，比如与、或、非运算。\n1 2  \u0026amp;\u0026amp; || ! \u0026lt; \u0026gt; \u0026lt;= \u0026gt;= == ${not empty num}   ","description":"今天主要学习的是Session和Cookie以及JSP内置对象和作用域的学习，还顺便学习了EL表达式。一步步的演进，让我懂得了技术的发展并不是一蹴而就的，有不方便的地方就要去解决，比如EL表达式就极大的简化了JSP页面的代码。相信还会有更加简便的工具来代替EL表达式；","id":6,"section":"posts","tags":["JavaWeb",""],"title":"4.24_Session、Cookie和EL学习","uri":"http://think.pengchangwen.site/posts/session-cookie-el-study/"},{"content":"★第一部分 Tomcat介绍 tomcat是什么？ Tomcat是一个Web应用服务器，它可以使得你写的Java程序被别人访问（通过网络），类似的Web应用服务器还有xxx、xxx、xxx。\n如何安装tomcat？  下载tomcat9.0.34，下载地址是：https://mirrors.tuna.tsinghua.edu.cn/apache/tomcat/tomcat-9/v9.0.34/bin/apache-tomcat-9.0.34-windows-x64.zip 解压到指定目录，比如：D:\\Apps\\JavaEE  tomcat压缩包内各个文件夹的作用  bin：存放各个平台下启动和停止tomcat服务的脚本文件，比如Mac下使用startup.sh就可以启动tomcat，windows下是用startup.bat启动； conf：存放各种tomcat服务器的配置文件，比如配置端口； lib：一些jar包，供tomcat使用，也可以拷出来给其它Java程序使用； logs：记录tomcat服务器运行的日志信息； temp：存放tomcat运行时的临时文件，比如文件的上传和下载（临时）； webapps：存放允许被客户端访问的资源（如Java程序、图片等）； work：存放tomcat将JSP转换之后的Servlet文件；  如何在IDEA中创建第一个tomcat应用程序？  创建JavaEE程序 配置本地Tomcat服务器 配置访问路径  ★第二部分 Servlet详解 什么是Servlet？ Servlet是Java Web开发的基石，与平台无关的服务器组件，它是运行在Servlet容器（其实也就是Web应用服务器），负责与客户端通信；\n主要功能  创建并返回基于客户请求的动态HTML页面（比如登录成功页面、登录失败页面）； 与数据库进行通信；  如何使用Servlet？ Servlet本身是一组接口（接口是描述功能的），其接口在javax.servlet包内。因此需要自定义一个类，并且实现servlet接口，于是这个类就具备了接受客户端请求以及做出响应的功能；\nservlet程序所处的物理路径（WEB-INF目录中）不允许被直接访问，所以需要做一个映射（注解应该是基于这个）。\n如何映射servlet程序？   方法一：在web.xml中配置（基于XML文件）\n例如通过浏览器/myservlet路径访问MyServlet程序，通过相同的MyServlet间接映射。在web.xml做如下设置即可：\n1 2 3 4 5 6 7 8  \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;MyServlet\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;tech.langchao2020.servlet.MyServlet\u0026lt;/servlet-class\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;MyServlet\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;/myservlet\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt;   自定义类中的service方法可以响应客户端的请求，比如返回一句话（值得注意的是会有中文乱码，因此需要转码）：\n1 2 3 4 5 6  @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException { System.out.println(\u0026#34;服务端已经接收到请求....\u0026#34;); servletResponse.setContentType(\u0026#34;text/html;charset=UTF-8\u0026#34;); servletResponse.getWriter().write(\u0026#34;你好啊，朋友！\u0026#34;); }   通过servletRequest对象的getParameter()方法可以接收来自客户端带来的参数：\n1 2  String id = servletRequest.getParameter(\u0026#34;id\u0026#34;); System.out.println(\u0026#34;服务端已经接收到请求,参数是：\u0026#34; + id);     方法二：通过注解的方式\n1 2 3 4 5 6 7 8 9 10 11  @WebServlet(\u0026#34;/demo1\u0026#34;) public class MyServlet implements Servlet { //此处省略需要重写的其它四个方法  @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException { String id = servletRequest.getParameter(\u0026#34;id\u0026#34;); System.out.println(\u0026#34;服务端已经接收到请求,参数是：\u0026#34; + id); servletResponse.setContentType(\u0026#34;text/html;charset=UTF-8\u0026#34;); servletResponse.getWriter().write(\u0026#34;你好啊，朋友！\u0026#34;); } }     扩展 java和javax的区别，java.x开头的是最基础的功能包，javax.x是后来扩展的功能包，都是jdk官方提供的；\nServlet生命周期 过程  客户端请求Servlet时，tomcat会查询当前的实例化对象是否存在，如果不存在则通过反射自动创建。如果存在，直接执行第三步； 调用init()方法完成初始化操作； 调用service()方法完成业务逻辑操作； 关闭tomcat服务器时，会调用destor()方法销毁当前对象（释放资源）；  生命周期方法   1 2 3 4  @Override public void init(ServletConfig servletConfig) throws ServletException { System.out.println(\u0026#34;对Servlet执行初始化操作...\u0026#34;); }     1 2 3 4  @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException { System.out.println(\u0026#34;对Servlet执行了业务方法....\u0026#34;); }     1 2 3 4  @Override public void destroy() { System.out.println(\u0026#34;销毁了Servlet对象....\u0026#34;); }     tomcat通过反射机制创建自定义类的对象 创建自定义类并实现Servlet接口时并没有自己手动new一个MyServlet对象，但这并不代表这个类并没有被实例化，而是tomcat容器帮你做了这个事情。它是通过反射机制创建的，反射创建对象一般是通过无参构造方法。\n通过反射调用无参构造：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  package tech.langchao2020.servlet; import java.lang.reflect.Constructor; public class TomcatTest { public static void main(String[] args) { // 拿到全类名  String str = \u0026#34;tech.langchao2020.servlet.LifeServlet\u0026#34;; // 获取运行时类  try { Class clazz = Class.forName(str); // 获取无参构造  Constructor constructor = clazz.getConstructor(); // System.out.println(constructor);  // 构造器创建对象  Object object = constructor.newInstance(); System.out.println(object); } catch (Exception e) { e.printStackTrace(); e.printStackTrace(); } } }   ServletConfig接口 改接口是用来描述Servlet的基本信息；\nservletConfig常用接口方法  1 2 3  getServletName(); // 获取Servlet的全类名（带包的类名） getInitParameter(username); // 获取init参数的值，这个值是来自web.xml里面的值（需要配置） getInitParameterNames();// 获取所有的init参数名     1 2 3 4 5 6 7 8  \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;MyServlet\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;tech.langchao2020.servlet.MyServlet\u0026lt;/servlet-class\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;username\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;admin\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;/servlet\u0026gt;     getServletContext()方法返回ServletContext对象，是Servlet上下文（整个servlet的管理者），这是常用的方法，以上三个并不常用；能拿到很多关于Servlet的信息，比如上下文路径getContextPath()、tomcat服务器信息getServletInfo()；\n  ServletConfig 和 ServletContext的区别：\n ServletConfig 作用于某个特定的servlet实例，每个servlet都有对应的ServletConfig，实例化后是一个局部对象； ServletContext作用于整个Web应用，一个Web应用对应于一个ServletContext，多个servlet实例（如HelloServlet、LifeServlet、TestServlet）对应一个ServletContext，实例化后是一个全局对象；    Servlet层次上的改进 Servlet接口的层次 Servlet \u0026mdash;》GenericServlet \u0026mdash;》HttpServlet\n Servlet\n GenericServlet\n HttpServlet\n   GenericServlet实现了Servlet接口，同时屏蔽（继承的作用之一）了其子类并不常用的方法。实际使用中只需要将自定义的类继承自HttpServlet即可，然后重写doGet() 和 doPost() 方法即可；\n1 2 3 4 5 6 7 8 9 10 11 12  @WebServlet(\u0026#34;/hello\u0026#34;) public class HelloServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { resp.getWriter().write(\u0026#34;doGet! Hello langchao;\u0026#34;); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { resp.getWriter().write(\u0026#34;doPost! Hello langchao;\u0026#34;); } }   Http请求有很多种类型（是不是要补习一点HTTP协议的相关知识？），常见的有下面四种：\n GET 读取 POST 保存 PUT 修改 DELETE 删除  CRUD指的分别是：\n Create Read Update Delete  ★第三部分 JSP详解 什么是JSP？ JSP本质上就是Servlet，JSP主要负责与客户端交互（界面上的交互），将最终的页面呈现给用户；一个JSP可能包含HTML、CSS、JavaScript、Java部分。(从开发角度来看就是在HTML中嵌入Java代码)\n当服务器接收到一个后缀是.jsp的请求时，则该将请求交给JSP引擎去处理；每一个JSP页面第一次被访问的时候，JSP引擎会将它翻译成一个Servlet文件，再由Web容器调用该Servlet文件完成响应；\nJSP中嵌入Java代码的方式   方式1——JSP脚本，执行Java逻辑代码\n1  \u0026lt;% Java代码 %     方式2——JSP声明，用来定义Java方法\n1 2 3  \u0026lt;%! 声明Java方法代码 %\u0026gt;   1 2 3 4 5 6 7 8 9 10  \u0026lt;%-- 声明Java方法--%\u0026gt; \u0026lt;%! public String test() { return \u0026#34;Hello String!\u0026#34;; } %\u0026gt; \u0026lt;%-- 调用--%\u0026gt; \u0026lt;% System.out.println(test()); %\u0026gt;     方式3——JSP表达式，把Java对象直接输出到HTML页面\n1  \u0026lt;%= Java变量 %\u0026gt;   1 2 3 4 5 6 7 8 9 10 11  \u0026lt;%-- 声明Java方法--%\u0026gt; \u0026lt;%! public String test() { return \u0026#34;Hello String!\u0026#34;; } %\u0026gt; \u0026lt;%-- 调用--%\u0026gt; \u0026lt;% String hi = test(); %\u0026gt; \u0026lt;%=hi%\u0026gt;     例子（往index.jsp页面中添加Java对象成员变量中的数据）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  package tech.langchao2020.servlet.entity; public class Student { private String name; private int age; public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public Student(String name, int age) { this.name = name; this.age = age; } }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  \u0026lt;% List\u0026lt;Student\u0026gt; students = new ArrayList\u0026lt;\u0026gt;(); students.add(new Student(\u0026#34;张三\u0026#34;, 34)); students.add(new Student(\u0026#34;李四\u0026#34;, 43)); %\u0026gt; \u0026lt;table\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;姓名\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;年龄\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;% for (int i = 0; i \u0026lt; students.size(); i++) { %\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt; \u0026lt;%=students.get(i).getName()%\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; \u0026lt;%=students.get(i).getAge()%\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;% } %\u0026gt; \u0026lt;/table\u0026gt;     JSP内置对象（9个）  request  表示一次请求，由类HttpServletRequest产生   response  表示一次响应，由类HttpServletResponse产生   pageContext  页面上下文，可以获取页面信息，由类PageContext产生   session  表示一次会话，保存用户信息，由HttpSession产生   application  表示当前Web应用，是全局对象，保存所有用户共享信息，由类ServletContext产生   config  当前JSP对应的Servlet的ServletConfig对象，获取当前Servlet信息   out  由JspWriter类产生，用于向浏览器输出数据   page  当前JSP对应的Servlet对象，由Servlet产生   exception  表示JSP页面异常信息，来自Exception    常用的是：request、response、seesion、application、pageContext\nrequest常用方法  String getParameter(key) 获取客户端传来的参数 void setAttribute(String key, Object value) 通过键值对的形式来保存数据。 （Web容器/服务端内部页面传递数据需要使用到） Objcet getAttribute(String) 通过key取出value； RequestDispatcher getRequestDispatcher(String path)返回一个RequestDispatcher 对象，该对象的forwar()方法用于请求转发 String[] getParameterValues() 获取客户端传来的多个相同的key的值 void setCharaterEncoding(String charset) 指定每个请求的编码  ","description":"4.23日学习Tomcat、Servlet以及部分JSP的内容，主要是做了一些笔记。对请求转发这块得继续加强熟练度。","id":7,"section":"posts","tags":["JavaWeb",""],"title":"4.23_Servlet和JSP学习","uri":"http://think.pengchangwen.site/posts/servlet-jsp-study/"},{"content":"★0、前言 　我们生活的这个时代充满着前所未有的机会：如果你有雄心，又不乏智慧，那么不管你从何处起步，你都可以沿着自己所选择的道路登上事业的顶峰。\n　不过，有了机会，也就有了责任。今天的公司并不怎么管员工的职业发展；实际上，知识工作者必须成为自己的首席执行官。你应该在公司中开辟自己的天地，知道何时改变发展道路，并在可能长达50年的职业生涯中不断努力、干出实绩。要做好这些事情，你首先要对自己有深刻的认识——不仅清楚自己的优点和缺点，也知道自己是怎样学习新知识和与别人共事的，并且还明白自己的价值观是什么、自己又能在哪些方面做出最大贡献。因为只有当所有工作都从自己的长处着眼，你才能真正做到卓尔不群。\n　历史上的伟人——拿破仑、达芬奇、莫扎特——都很善于自我管理。这在很大程度上也是他们成为伟人的原因。不过，他们属于不可多得的奇才，不但有着不同于常人的天资，而且天生就会管理自己，因而才取得了不同于常人的成就。而我们当中的大多数人，甚至包括那些还算有点天赋的人，都不得不通过学习来掌握自我管理的技巧。\n　我们必须学会自我发展，必须知道把自己放在什么样的位置上，才能做出最大的贡献，而且还必须在长达50年的职业生涯中保持着高度的警觉和投入——也就是说，我们得知道自己应该何时换工作，以及该怎么换。\n★1、我的长处是什么？ **多数人都以为他们知道自己擅长什么，其实不然！**更多的情况是，人们只知道自己不擅长什么——即便是在这一点上，人们也往往认识不清。然而，一个人要有所作为，只能靠发挥自己的长处，而如果从事自己不太擅长的工作是无法取得成就的，更不用说那些自己根本干不了的事情。\n　以前的人没有什么必要去了解自己的长处，因为一个人的出身就决定了他一生的地位和职业：农民的儿子也会当农民，工匠的女儿会嫁给另一个工匠等。但是，现在人们有了选择。我们需要知己所长，才能知己所属。\n　要发现自己的长处，唯一途径就是回馈分析法（feedback analysis）。每当做出重要决定或采取重要行动时，你都可以事先记录下自己对结果的预期。9到12个月后，再将实际结果与自己的预期比较。我本人采用这种方法已有15到20年了，而每次使用都有意外的收获。\n　比如，回馈分析法使我看到，我对专业技术人员，不管是工程师、会计师还是市场研究人员，都容易从直觉上去理解他们。这令我大感意外。它还使我看到，我其实与那些涉猎广泛的通才没有什么共鸣。\n　回馈分析法并不是什么新鲜的东西。早在14世纪，这种方法由一个原本会永远默默无闻的德国神学家发明，大约150年后被法国神学家约翰·加尔文和西班牙神学家圣依纳爵分别采用。他们都把这种方法用于其信徒的修行。事实上，回馈分析法使他们的信徒养成了一种始终注重实际表现和结果的习惯，这也是他们创立的教派——加尔文教会和耶稣会——能够主宰欧洲长达30年的原因。\n　**我们只要持之以恒地运用这个简单的方法，就能在较短的时间内（可能两三年），发现自己的长处——这是你需要知道的最重要的事情。**在采用这种方法之后，你就能知道，自己正在做（或没有做）的哪些事情会让你的长处无法发挥出来。同时，你也将看到自己在哪些方面能力不是特别强。最后，你还将了解到自己在哪些方面完全不擅长，做不出成绩来。\n　根据回馈分析的启示，你需要在几方面采取行动。\n　首先，最重要的是，专注于你的长处，把自己放到那些能发挥长处的地方。\n　其次，加强你的长处。回馈分析会迅速地显示，你在哪些方面需要改善自己的技能或学习新技能。它还将显示你在知识上的差距——这些差距通常都可以弥补。数学家是天生的，但是人人都能学习三角学。\n　第三，发现任何由于恃才傲物而造成的偏见和无知，并且加以克服。有太多的人，尤其是那些术业有专攻的人，往往对其他领域的知识不屑一顾，或者认为聪明的头脑就可取代知识。比如，很多一流的工程师遇上与人相关的事就束手无策，他们还以此为荣——因为他们觉得，对条理清晰的工程师头脑来说，人太混乱无序了。与此形成鲜明对照的是，人力资源方面的专业人员常常以他们连基本的会计知识或数量分析都一无所知而自傲。不过，人们要是对这样的无知还沾沾自喜的话，那无异于自取灭亡。其实，要让自己的长处得到充分发挥，你就应该努力学习新技能、汲取新知识。\n　**另外一点也同样重要——纠正你的不良习惯。所谓不良习惯，是指那些会影响你的工作成效和工作表现的事情。这样的习惯能很快地在回馈中反映出来。**例如，一位企划人员可能发现自己美妙的计划最终落空，原因是他没有把计划贯彻到底。同那些才华横溢的人一样，他也相信好的创意能够移动大山。但是，真正移山的是推土机，创意只不过是为推土机指引方向，让它知道该到何处掘土。这位企划人员必须意识到不是计划做好就大功告成，接下来还得找人执行计划，并向他们解释计划，在付诸行动前须做出及时的调整和修改，最后要决定何时中止计划。\n　与此同时，回馈还会反映出哪些问题是由缺乏礼貌造成的。礼貌是一个组织的润滑剂。两个移动物相互接触时发生摩擦是一个自然规律，不仅无生命的物体是这样，人类也是如此。礼貌，其实也很简单，无非是说声“请”和“谢谢”，记住别人的名字，或问候对方家人这样的小事，但就是这种不起眼的细节，使得两个人能够融洽相处，不管他们彼此之间是否有好感。许多聪明人，尤其是聪明的年轻人，没有意识到这一点。如果回馈分析表明某个人只要一遇到需要别人合作的事就屡屡失败，那么很可能就意味着这个人的举止不大得体——也就是缺乏礼貌。\n　把预期和实际结果进行比较，也会发现自己不擅长做什么。我们每个人都有许多一窍不通、毫无天分的领域，在这些领域我们甚至连平庸的水平都达不到。人们，尤其是知识工作者，就不应该试图去完成这些领域的工作和任务。他们应该尽量少把精力浪费在那些不能胜任的领域上，因为“从无能到平庸”要比“从一流到卓越”需要人们付出多得多的努力。然而，大多数人，尤其是教师，还有组织，都一门心思要把能力低下的人变成合格者。其实，他们还不如把精力、资源和时间花在将称职者培养成佼佼者上。\n★2、我的工作方式是怎样的？ 　令人惊讶的是，很少有人知道自己平时是怎样把事情给做成的。实际上，我们当中的大多数人甚至不知道不同人有着不同的工作方式和表现。许多人不是以他们习惯的方式工作，这当然就容易造成无所作为。对于知识工作者来说，“我的工作方式是怎样的？”可能比“我的长处是什么？”这个问题更加重要。\n　同一个人的长处一样，一个人的工作方式也是独一无二的——这是由人的个性所决定的。不管个性是先天决定的，还是后天培养的，它肯定是早在一个人进入职场前就形成了。正如一个人擅长什么、不擅长什么是既定的一样，一个人的工作方式也基本固定，它可以略微有所调整，但是不可能完全改变——当然也不会轻易改变。而且就像人们从事自己最拿手的工作容易做出成绩一样，他们要是采取了自己最擅长的工作方式也容易取得成就。通常，几个常见的个性特征就决定了一个人的工作方式。\n我属于读者型，还是听者型？\n　首先，你要搞清楚的是，你是读者型（习惯阅读信息）还是听者型（习惯听取信息）的人。绝大多数人甚至都不知道还有“读者型”和“听者型”之说，而且很少有人既是读者型又是听者型。知道自己属于哪种类型的人更少。但是，有一些例子说明了这样的无知可能造成多大的危害。\n　德怀特·艾森豪威尔担任欧洲盟军最高统帅时，一直是新闻媒体的宠儿。他的记者招待会以其独特的风格出名——不管记者提出什么问题，艾森豪威尔将军都从容地对答如流。无论是介绍情况，还是解释政策，他都能够用两三句言简意赅的话就说清楚。十年后，艾森豪威尔当上了总统，当年曾对他十分崇拜的同一批记者，这时却公开瞧不起他。他们抱怨说，他从不正面回答问题，而是喋喋不休地胡侃着其他事情。他们总是嘲笑他回答问题时语无伦次，不合乎语法，糟蹋标准英语。\n　艾森豪威尔显然不知道自己属于读者型，而不是听者型。当他担任欧洲盟军最高统帅时，他的助手设法确保媒体提出的每一个问题至少在记者招待会开始前半小时以书面形式提交。这样，艾森豪威尔就完全掌握了记者提出的问题。而当他就任总统时，他的两个前任都是听者型——富兰克林·罗斯福和哈里·杜鲁门。这两位总统知道自己是听者型的，并且都喜欢举行畅所欲言的记者招待会。艾森豪威尔可能认为他必须去做两位前任所做的事。可是，他甚至连记者们在问些什么都从来没听清楚过。而且，艾森豪威尔并不是个极端的例子。\n　几年后，林登·约翰逊把自己的总统职位给搞砸了，这在很大程度上是因为他不知道自己是听者型的人。他的前任约翰·肯尼迪是个读者型的人，他搜罗了一些出色的笔杆子当他的助手，要求他们每次进行当面讨论之前务必先给他写通报。约翰逊留下了这些人，他们则继续写通报。可是他显然根本看不懂他们写的东西。不过，约翰逊以前当参议员时曾经表现非凡，因为议员首先必须是听者型。\n　**没有几个听者型的人可以通过努力变成合格的读者型——不管是主动还是被动的努力；反之亦然。**因此，试图从听者型转为读者型的人会遭受林登·约翰逊的命运，而试图从读者型转为听者型的人会遭受德怀特·艾森豪威尔的命运。他们都不可能发挥才干或取得成就。\n★3、我如何学习？ 要了解一个人的工作方式，需要弄清的第二点是，他是如何学习的。\n　许多一流的笔杆子都不是好学生——温斯顿·邱吉尔就是一例。在他们的记忆中，上学往往是十足的折磨。然而，他们的同学有这种记忆的却很少。他们可能在学校里得不到什么乐趣，对他们来说上学的最大痛苦是无聊。有关这个问题的解释是，笔头好的人一般不靠听和读来学习，而靠写来学习，这已成了一种规律。学校不让他们以这种方式学习，所以他们的成绩总是很糟糕。\n　所有的学校都遵循这样的办学思路：只有一种正确的学习方式，而且人人都得遵从。但是，对学习方式跟别人不大一样的学生来说，被迫按学校教的方式来学习就是地狱。实际上，学习大概有六七种不同的方式。\n　像邱吉尔这样的人靠写来学习。还有些人以详尽的笔记来学习。例如，贝多芬留下了许多随笔小抄，然而他说，实际上他作曲时从来不看这些随笔小抄。当被问及他为什么还要用笔记下来时，据说他回答道：“如果我不马上写下来的话，我很快就会忘得一干二净。如果我把它们写到小本子上，我就永远不会忘记了，也用不着再看一眼。”有些人在实干中学习。另一些人通过听自己讲话学习。\n　我认识一位公司总经理，他把一个平庸的小家族企业发展成行业领军企业。他是一个通过讲话学习的人。他习惯于每周一次把全体高层管理人员召集到他的办公室，随后对他们讲上两三个小时。他总是提出政策性问题，在每一个问题上提出三种不同观点。但他很少请这帮同事发表意见或提出问题，他只需要听众听他讲话。这就是他的学习方式。虽然他是一个比较极端的例子，但是通过讲话学习绝不是一种少见的方法。成功的出庭律师也以同样的方式学习，许多诊断医师也是如此（我自己也是这样）。\n　在所有最重要的自我认识当中，最容易做到的就是知道自己是怎样学习的。当我问人们：“你怎么学习？”大多数人都知道答案。但是，当我问：“你根据这个认识来调整自己的行为吗？”没有几个人回答“是”。然而，知行合一是取得成就的关键；如果知行不合一，人们就会无所作为。\n　我属于读者型还是听者型？我如何学习？这是你首先要问自己的问题。但是，光这些问题显然不够。要想做好自我管理，你还需要问这样的问题：我能与别人合作得好吗？还是喜欢单枪匹马？如果你确实有与别人进行合作的能力，你还得问问这个问题：我在怎样的关系下与他人共事？\n　有些人适合当部属。二战时期美国的大英雄乔治·巴顿将军是一个很好的例子。巴顿是美军的一名高级将领。然而，当有人提议他担任独立指挥官时，美国陆军参谋长（可能也是美国历史上最成功的伯乐）乔治·马歇尔将军说：“巴顿是美国陆军造就的最优秀的部下，但是，他会成为最差劲的司令官。”\n　一些人作为团队成员工作最出色；另一些人单独工作最出色。一些人当教练和导师特别有天赋；另一些人却没能力做导师。\n　另一个关键的问题是，我如何才能取得成果——是作为决策者还是作为顾问？\n　许多人做顾问时的表现会很出色，但是不能够承担决策的负担和压力。与此相反，也有许多人需要顾问来迫使他们思考，随后他们才能做出决定，接着迅速、自信和大胆地执行决定。\n　顺便说一下，一个组织的二号人物在提升到一号职位时常常失败，也正是因为这个原因。最高职位需要一个决策者，而一个强势的决策者常常把其信赖的人放在二号位置，当他的顾问。顾问在二号位置上往往是很出色的，但是换到一号位置，他就不行了。他虽然知道应该做出什么样的决定，但是不能接受真正做决定的责任。\n　其他有助于认识自我的重要问题包括：\n 1、我是在压力下表现出色，还是适应一种按部就班、可预测的工作环境？\n2、我是在一个大公司还是在一个小公司中工作表现最佳？\n3、在各种环境下都工作出色的人寥寥无几。\n 　我不止一次地看到有些人在大公司中十分成功，换到小公司中则很不顺利。反过来也是如此。下面这个结论值得我们反复强调：**不要试图改变自我，因为这样你不大可能成功。但是，你应该努力改进你的工作方式。**另外，不要从事你干不了或干不好的工作。\n★4、我的价值观是什么？ 　要能够自我管理，你最后不得不问的问题是：我的价值观是什么？这不是一个有关伦理道德的问题。道德准则对每一个人都一样。要对一个人的道德进行测试，方法很简单。我把它称为“镜子测试”。\n　20世纪初，德国驻英国大使是当时在伦敦所有大国中最受尊重的一位外交官。显然，他命中注定会承担重任，即使不当本国的总理，至少也要当外交部长。然而，在1906年，他突然辞职，不愿主持外交使团为英国国王爱德华七世举行的晚宴。这位国王是一个臭名昭著的色鬼，并且明确表示他想出席什么样的晚宴。据有关报道，这位德国大使曾说：“我不想早晨刮脸时在镜子里看到一个皮条客。”——这就是镜子测试。\n　我们所遵从的伦理道德要求你问自己：我每天早晨在镜子里想看到一个什么样的人？在一个组织或一种情形下合乎道德的行为，在另一个组织或另一种情形下也是合乎道德的。但是，道德只是价值体系的一部分——尤其对于一个组织的价值体系来说。\n　如果一个组织的价值体系不为自己所接受或者与自己的价值观不相容，人们就会备感沮丧，工作效力低下。\n　让我们来看看一位十分成功的人力资源主管的经历。这位主管所在的公司被一家大企业收购。收购之后，她得到了提升，从事的是她以前做得最出色的工作，包括为重要职位挑选人才。这位主管深信，在选人时，公司只有在排除内部的所有可能人选后才能从外部招聘人才。但是她的新公司认为应该首先从外部招聘，以吸收新鲜血液。对于这两种方式，需要说明的一点是，根据我的经验，适当的方式是两者兼顾。然而，这两种方式在根本上是互不相容的——表面上是政策不同，实质是价值观的不同。这说明在该公司人们对以下三个问题有着不同看法：组织与员工之间是怎样的关系；组织应该为员工以及员工的发展承担何种责任；一个人对企业最重要的贡献是什么。经过几年挫折，这位主管最终辞职——尽管她的经济损失很大。她的价值观和这个组织的价值观就是无法融合。\n　同样，一家制药公司无论是通过不断的小幅改进，还是通过几次费用高昂、风险巨大的“突破”来取得出色业绩，都不是一个经济问题。这两种战略的结果可能都差不多。实质上，这是两种价值体系之间的冲突。一种价值体系认为公司的贡献是帮助医生把他们已经在做的工作锦上添花，另一种价值体系的取向是进行更多的科学发现。\n　至于一个企业的经营是着眼于短期结果，还是注重长远发展，这同样是价值观问题。财务分析师认为，企业可两者同时兼顾。成功的企业家知道得更清楚。诚然，每一家公司都必须取得短期成果。但是在短期成果与长期增长之间的冲突中，每一家公司都将决定自己所选择的重点。从根本上说，这是一种关于企业职能与管理层责任的价值观冲突。\n　价值观冲突并不限于商业组织。美国发展最快的一个牧师教会，其衡量工作成败的尺度是新教徒的人数。它的领导层认为，重要的是有多少新教徒入会。随后，上帝将满足他们的精神需求，或者至少会满足足够比例的新教徒的需求。另一个福音派牧师教会认为，重要的是人们的精神成长。这个教会慢慢地让那些形式上入会但精神上并没有融入教会生活的新教徒选择了离开。\n　这同样不是一个数量问题。乍一看，第二个教会好像发展较慢。但是，它留住新教徒的比例要远高于第一个。换言之，它的发展比较稳固。这也不是一个神学问题（至少首先并不是神学问题），而是有关价值观的问题。在一次公开辩论中，一位牧师这样说：“除非你先加入教会，否则你永远找不到天国之门。”而另一位牧师反驳说：“不，除非你先有心寻找天国之门，否则你就不属于教会。”\n　**组织和人一样，也有价值观。为了在组织中取得成效，个人的价值观必须与这个组织的价值观相容。两者的价值观不一定要相同，但是必须相近到足以共存。**不然，这个人在组织中不仅会感到沮丧，而且做不出成绩。\n　一个人的工作方式和他的长处很少发生冲突，相反，两者能产生互补。但是，一个人的价值观有时会与他的长处发生冲突。一个人做得好甚至可以说是相当好、相当成功的事情——可能与其价值体系不吻合。在这种情况下，这个人所做的工作似乎并不值得贡献毕生的精力（甚至没必要贡献太多的精力）。\n　如果可以，请允许我插入一段个人的故事。多年前，我也曾不得不在自己的价值观和做得很成功的工作之间做出选择。20世纪30年代中期，我还是一个年轻人，在伦敦做投资银行业务，工作非常出色。这项工作显然能发挥我的长处。然而，我并不认为自己担任资产管理人是在做贡献。我认识到，我所重视的是对人的研究。我认为，一生忙于赚钱、死了成为墓地中的最大富翁没有任何意义。当时我没有钱，也没有任何就业前景。尽管当时大萧条仍在持续，我还是辞去了工作。这是一个正确的选择。换言之，价值观是并且应该是最终的试金石。\n★5、我属于何处？ 　少数人很早就知道他们属于何处。比如，数学家、音乐家和厨师，通常在四五岁的时候就知道自己会成为数学家、音乐家和厨师了。物理学家通常在十几岁甚至更早的时候就决定了自己的工作生涯。但是，**大多数人，尤其是很有天赋的人，至少要过了二十五六岁才知道他们将身属何处。**然而，到这个时候，他们应该知道上面所谈的三个问题的答案：\n 1、我的长处是什么？\n2、我的工作方式是怎样的？\n3、我的价值观是什么？\n 随后，他们就能够决定自己该向何处投入精力。或者，他们应该能够决定自己不属于何处。\n　已经知道自己在大公司里干不好的人，应该学会拒绝在一个大公司中任职。已经知道自己不适合担任决策者的人，应该学会拒绝做决策工作。巴顿将军（他自己大概永远不知道这一点）本来应该学会拒绝担任独立总指挥的。\n　同样重要的是，知道上述三个问题的答案，也使得一个人能够坦然接受一个机会、一个邀请或一项任务。他们会说：“是的，我将做这件事。但是，我将按照我自己的特点，采取这样的方式来做这件事，进行这样的组织安排，这样来处理当中所牵涉的关系。这是我在这个时间范围内应该会取得的成果，因为这就是我。”\n　**成功的事业不是预先规划的，而是在人们知道了自己的长处、工作方式和价值观后，准备把握机遇时水到渠成的。**知道自己属于何处，可使一个勤奋、有能力但原本表现平平的普通人，变成出类拔萃的工作者。\n★6、我该做什么贡献？ 　综观人类的发展史，绝大多数人永远都不需要提出这样一个问题：我该做出什么贡献？因为他们该做出什么贡献是由别人告知的，他们的任务或是由工作本身决定的（例如农民或工匠的任务），或是由主人决定的（例如佣人的任务）。\n　以前的人大多都处于从属地位，别人吩咐他们做什么，就做什么，这被认为是理所当然的。甚至到了20世纪50年代和60年代，那时涌现出的知识工作者（即所谓的“组织人”，organization man）还指望公司的人事部为他们做职业规划。\n　随后，到20世纪60年代末，就再没有人想让别人来安排自己的职业生涯了。年轻的男男女女开始提出这个问题：我想做什么？而他们所听到的答案就是“你们自行其是吧”。但是，这种回答同“组织人”听命公司的做法一样错误。那些相信自行其是就能做出贡献、实现抱负、取得成功的人，一般连三点中的任何一点都做不到。\n　尽管如此，我们还是不能走回头路，让别人来吩咐、安排自己要干什么。对于知识工作者来说，他们还不得不提出一个以前从来没有提出过的问题：我的贡献应该是什么？要回答这个问题，他们必须考虑三个不同的因素：\n 1、当前形势的要求是什么？\n2、鉴于我的长处、我的工作方式以及我的价值观，我怎样才能对需要完成的任务做出最大贡献？\n3、必须取得什么结果才能产生重要影响？\n 　请看一位新任命的医院院长的经历。这是一所享有盛名的大医院，30年来一直就靠名气顺利经营着。新院长上任后决定了自己应做的贡献：两年内在医院的某个重要领域建立起卓越服务的标准。他决定以急诊室为重点，因为该院的急诊室地方比较大，受人注意，而又秩序混乱。他决定，到急诊室就诊的每一个患者必须在60秒钟之内由一名合格的护士接待。一年之内，该医院的急诊室变成了美国所有医院的样板，又过了两年，整个医院的面貌焕然一新。\n　正如这个事例所表明的，把眼光放得太远是不大可能的——甚至不是特别有效。一般来说，一项计划的时间跨度如果超过了18个月，就很难做到明确和具体。因此，在多数情况下我们应该提出的问题是：\n 1、我在哪些方面能取得将在今后一年半内见效的结果？\n2、如何取得这样的结果？\n 　回答这个问题时必须对几个方面进行权衡：\n　首先，这些结果应该是比较难实现的——用当前的一个时髦词说，就是要有“张力”（stretching）。但是，这些结果也应该是能力所及的。设定一个不能实现的目标或者只能在可能性微乎其微的情况下实现的目标，根本不能叫雄心勃勃，简直就是愚蠢。\n　其次，这些结果应该富有意义，要能够产生一定影响。\n　最后，结果应该明显可见，如果可能的话，还应当能够衡量。确定了要实现的结果之后，接着就可以制订行动方针：做什么，从何处着手，如何开始，目标是什么，在多长时间内完成。\n★7、我要如何处理人际关系？ 　除了少数伟大的艺术家、科学家和运动员，很少有人是靠自己单枪匹马而取得成果的。不管是组织成员还是个体职业者，大多数人都要与别人进行合作，并且是有效的合作。要实现自我管理，你需要对自己的人际关系负起责任。这包括两部分内容。\n　首先是要接受：别人是和你一样的个体这个事实。\n　每个人都会执意展现自己作为人的个性。这就是说，**每个人都有自己的长处，自己的做事方式和自己的价值观。因此，要想卓有成效，你就必须知道共事者的长处、工作方式和价值观。**这个道理听起来让人很容易明白，但是没有几个人真正会去注意。\n　一个习惯于写报告的人就是个典型的例子——他在第一份工作时就培养起写报告的习惯，因为他的老板是一个读者型的人，而即使下一个老板是个听者型，此人也会继续写着那肯定没有任何结果的报告。这位老板因此肯定会认为这个员工愚蠢、无能、懒惰，肯定干不好工作。但是，如果这个员工事先研究过新老板的情况，并分析过这位老板的工作方式，这种情况本来可以避免。\n　老板既不是组织结构图上的一个头衔，也不是一个“职能”。他们是有个性的人，他们有权以自己最得心应手的方式来工作。与他们共事的人有责任观察他们，了解他们的工作方式，并做出相应的自我调整，以适应老板最有效的工作方式。事实上，这就是“管理”上司的秘诀。\n　这种方法适用于所有与你共事的人。每个人都有他自己的做事方法，也有权按照自己的方式来工作，而不是按你的方法来工作。重要的是，他们能否有所作为以及他们持有什么样的价值观。至于工作方式，人各有别。提高效力的第一个秘诀是了解跟你合作和你要依赖的人，以利用他们的长处、工作方式和价值观。工作关系应当既以工作为基础，也以人为基础。\n　人际关系责任的第二部分内容是沟通责任。\n　在我或是其他人开始给一个组织做咨询时，我们听到的第一件事都与个性冲突有关。其中大部分冲突都是因为：人们不知道别人在做什么，他们又是采取怎样的工作方式，专注于做出什么样的贡献以及期望得到怎样的结果。而这些人不了解情况的原因是，他们没有去问，结果也就不得而知。这种不去问明情况的做法，与其说是反映了人类的愚蠢，倒不如说是历史使然。\n　在以前，人们没必要把这些情况告诉任何人。比如在中世纪的城市，一个区的每一个人从事的行业都一样。在乡村，土地刚一解冻，山谷里的每一个人就开始播种同一种农作物。即使有少数人做的事情和大家不一样，他们也是单独工作，因此不需要告诉任何人他们在做什么。\n　而现在，大多数人都与承担着不同任务和责任的人一道工作。市场营销副总裁可能是销售出身，知道有关销售的一切，但是，对于自己从未做过的事情，比如定价、广告、包装等等，就一无所知了。所以，那些正在做这些工作的人必须确保营销副总裁懂得他们设法做的是什么、他们为什么要做这件事、他们将如何去做以及期望取得什么结果。\n　如果营销副总裁不懂得这些高层次的、知识型的专业人士在做什么，错主要在后者身上，而不在自己。反过来说，营销副总裁的责任则是确保他的所有同事都知道自己是怎样看待营销这项工作的：他的目标是什么、他如何工作，以及他对他本人和他的每一个同事有什么期望。\n　即使一些人懂得负起人际关系责任的重要性，他们和同事的交流也往往不够。他们总是有所顾虑，怕别人把自己看成是一个冒昧、愚蠢、爱打听的人。他们错了。因为我们看到，每当有人找到他的同事说“这是我所擅长的工作。这是我的做事方式。这是我的价值观。这是我计划做出的贡献和应当取得的成果”，这个人总会得到如此回答：“这太有帮助了，可你为什么不早点告诉我？”\n　如果一个人继续问道：“那么，关于你的长处、你的工作方式、你的价值观以及你计划做出的贡献，我需要知道什么？”他也会得到类似的答复——据我的经验，无一例外。事实上，知识工作者应该向与他们共事的每一个人，不管是下属、上司、同事还是团队成员，都发出这样的疑问。而且，每次提出此类问题，都会得到这样的回答：“谢谢你来问我。但是，你为什么不早点问我？”\n　**组织已不再建立在强权的基础上，而是建立在信任的基础上。人与人之间相互信任，不一定意味着他们彼此喜欢对方，而是意味着彼此了解。**因此，人们绝对有必要对自己的人际关系负责。这是一种义务。不管一个人是公司的一名成员，还是公司的顾问、供应商或经销商，他都需要对他的所有共事者负起这种责任。所谓共事者，是指在工作上他所依赖的同事以及依赖他的同事。\n★8、我该如何管理后半生？ 　当多数人的工作是体力劳动时，你不必为自己的后半生担心。你只要继续从事你一直在做的工作就行了。如果你够幸运，能在工厂或铁路辛勤工作40年后撑下来，你就可以快乐地度过余生，什么也用不着干。然而，现在的多数工作都是知识工作，而知识工作者在干了40年后，仍能发挥余热，他们只是有些厌倦。\n　我们听到了许多有关经理人中年危机的谈论，“厌倦”这个词在其中频频出现。45岁时，多数经理人的职业生涯达到了顶峰，他们也知道这一点。在做了20年完全相同的工作之后，他们已经得心应手。但是他们学不到新东西，也没有什么新贡献，从工作中得不到挑战，因而也谈不上满足感。然而，在他们面前，还有20到25年的职业道路要走。这就是为什么经理人在进行自我管理后，越来越多地开始发展第二职业的原因。\n　发展第二职业有三种方式：\n　第一种是完全投身于新工作。\n　这常常只需要从一种组织转到另一种组织。例如，一家大公司某事业部的会计师成为一家中型医院的财务总监。但是也有越来越多的人转入完全不同的职业。例如，公司经理在45岁时进入政府内阁；或者中层管理人员在公司工作20年后离职，到法学院进修，成为一个小镇的律师。还有许多人在第一份职业中取得的成功有限，于是改行从事第二职业。这样的人有很多技能，他们也知道该如何工作。而且，他们需要一个社群——因为孩子已长大单飞，剩下一座空屋。他们也需要收入。但最重要的是，他们需要挑战。\n　为后半生做准备的第二种方式是，发展一个平行的职业。\n　许多人的第一职业十分成功，他们还会继续从事原有工作，或全职或兼职，甚至只是当顾问。但是，除此之外，他们会开创一项平行的工作，通常是在非营利机构，每周占用10个小时。例如，他们可能接手教会的管理，或者担任当地女童子军顾问委员会主席。他们也可能管理受虐妇女庇护所，担任当地公共图书馆的儿童图书管理员，或在学校董事会任职等。\n　最后一种方法是社会创业。\n　社会创业者通常是在第一职业中非常成功的人士。他们都热爱自己的工作，但是这种工作对他们已经不再有挑战性。在许多情况下，他们虽然继续做着原来的工作，但在这份工作上花的时间越来越少。他们同时开创了另一项事业，通常是非营利性活动。例如，我的朋友鲍勃·布福德创办了一个非常成功的电视公司，现在他仍然经营着。但与此同时，他还创建了一个与新教教会合作的非营利组织，也做得非常成功。现在他又创建了一个组织，专门指导社会创业者在经营原有业务的同时，如何管理自己另外创办的非营利机构。\n　**能管理好自己后半生的人总是少数。多数人可能“一干到底”，数着年头一年一年过去，直至退休。**但是，正是这些少数人，这些把漫长的工作寿命看做是自己和社会之机会的男男女女，才会成为领袖和模范。\n　**管理好后半生有一个先决条件：你必须早在你进入后半生之前就开始行动。**当30年前人们首次认识到工作寿命正在迅速延长时，许多观察家（包括我自己）认为，退休人员会越来越多地成为非营利机构的志愿者。可是，这种情况并没有发生。一个人如果不在40岁之前就开始做志愿者，那他60岁之后也不会去做志愿者。\n　同样，我认识的所有社会创业者，都是早在他们原有的事业达到顶峰之前就开始从事他们的第二事业。请看一名成功律师的例子。这位律师是一家大公司的法律顾问，他同时在自己所在的州开办了模特培训学校。早在他35岁左右的时候，他就开始志愿为学校提供法律咨询。40岁时被推选为一家学校的董事会成员。50岁时，他积累起了一笔财富，办起了自己的企业——建立并经营模特培训学校。然而此时，他依旧在那家他年轻时参与创建的公司里担任首席法律顾问，而且几乎是全职工作。\n　发展第二兴趣（而且是趁早发展）还有一个原因：任何人都不能指望在生活或工作中很长时间都不遭遇严重挫折。有一位很能干的工程师在45岁时错过了晋升的机会。另一位也很能干的普通学院的教授在42岁时认识到，即使她完全具备担任教授的资格，她永远也不会在一所有名的大学里获得教授职位。还有一位则是在家庭生活里出现了悲剧：婚姻破裂或者痛失子女。在这样的时刻，第二兴趣——不仅仅是业余爱好——还可能发挥重要作用。例如，这位工程师现在知道他在工作上并不十分成功。但是，在公司以外的活动中，例如负责教会资金的管理，他是成功的。一个人可能家庭破碎，但是他能在第二兴趣的活动中发现还有社区这个大“家庭”。\n　在一个崇尚成功的社会里，拥有各种选择变得越来越重要。从历史上来看，却没有“成功”一说。绝大多数人只期望坚守“适当的位置”。唯一的流动性是向下的流动性。然而，在知识社会里，我们期望每一个人都能取得成功。这显然是不可能的。对许多人来说，能避免失败就行。可是有成功的地方，就会有失败。因此，有一个能够让人们做出贡献、发挥影响力或成为“大人物”的领域，这不仅对个人十分重要，对个人的家庭也同样重要。这意味着人们需要找到一个能够有机会成为领袖、受到尊重、取得成功的第二领域——可能是第二份职业，也可能是平行的职业或社会创业。\n　自我管理中面临的挑战看上去比较明显，甚至非常基本，其答案可能不言自明，甚至近乎幼稚。但是，自我管理需要个人，尤其是知识工作者，做出以前从未做过的事情。实际上，自我管理需要每一个知识工作者在思想和行动上都要成为自己的首席执行官。更进一步来看，这样的转变——从一切听从别人吩咐的体力劳动者到不得不自我管理的知识工作者——也使得社会结构发生了深刻变化。\n　历史上每一个社会，甚至是个人主义倾向最强的社会，都认为（即使只是下意识地认为）两件事情是理所当然的：\n 1、组织比员工更长寿；\n2、大多数人从不挪地方。\n 　如今，情况恰恰相反。知识工作者的寿命超过了组织寿命，而且他们来去自如。于是，人们对自我管理的需要在人类事务中掀起了一场革命。\n","description":"据说，这篇长文对每个人都很有帮助。通过此文的借鉴，可以帮助你更好地规划自己的职业生涯和人生。","id":8,"section":"reproduced","tags":["转载",""],"title":"转载：自我管理","uri":"http://think.pengchangwen.site/reproduced/managing-oneself/"},{"content":"★《爱因斯坦：我的世界观》 　我们这些总有一死的人，命运是多么的奇特！我们每个人在这个世界上都只作一个短暂的逗留；目的何在，却无从知道，尽管有时自以为对此若有所感。但是，不必深思，只要从日常生活中就可以明白：人是为别人而生存的──首先是为那样一些人，我们的幸福全部依赖于他们的喜悦和健康；其次是为许多我们所不认识的人，他们的命运通过同情的纽带同我们密切结合在一起。我每天上百次的提醒自己：我的精神生活和物质生活都是以别人（包括生者和死者）的劳动为基础的，我必须尽力以同样的分量来报偿我所领受了的和至今还在领受着的东西。我强烈地向往着俭朴的生活。并且时常发觉自己占用了同胞的过多劳动而难以忍受。我认为阶级的区分是不合理的，它最后所凭借的是以暴力为根据。我也相信，简单淳朴的生活，无论在身体上还是在精神上，对每个人都是有益的。\n　我完全不相信人类会有那种在哲学意义上的自由。每个人的行为不仅受着外界的强制，而且要适应内在的必然。叔本华说：“人虽然能够做他所想做的，但不能要他所想要的。”这句格言从我青年时代起就给了我真正的启示；在我自己和别人的生活面临困难的时候，它总是使我们得到安慰，并且是宽容的持续不断的源泉。这种体会可以宽大为怀地减轻那种容易使人气馁的责任感，也可以防止我们过于严肃地对待自己和别人；它导致一种特别给幽默以应有地位的人生观。\n　要追究一个人自己或一切生物生存的意义或目的，从客观的角度来看，我总觉得是愚蠢可笑的。可是每个人都有一些理想，这些理想决定着他的努力和判断的方向。就在这个意义上，我从来不把安逸和享乐看作生活目的本身──我把这种伦理基础叫做“猪栏的理想”。照亮我的道路，是善、美和真。要是没有志同道合者之间的亲切感情，要不是全神贯注于客观世界──那个在艺术和科学工作领域里永远达不到的对象，那么在我看来，生活就会是空虚的。我总觉得，人们所努力追求的庸俗目标──财产、虚荣、奢侈的生活──都是可鄙的。\n　我有强烈的社会正义感和社会责任感，但我又明显地缺乏与别人和社会直接接触的要求，这两者总是形成古怪的对照。我实在是一个“孤独的旅客”，我未曾全心全意地属于我的国家、我的家庭、我的朋友，甚至我最为接近的亲人；在所有这些关系面前，我总是感觉到有一定距离而且需要保持孤独──而这种感受正与年俱增。人们会清楚地发觉，同别人的相互了解和协调一致是有限度的，但这不值得惋惜。无疑，这样的人在某种程度上会失去他的天真无邪和无忧无虑的心境；但另一方面，他却能够在很大程度上不为别人的意见、习惯和判断所左右，并且能够避免那种把他的内心平衡建立在这样一些不可靠的基础之上的诱惑。\n　我的政治理想是民主政体。让每一个人都作为个人而受到尊重，而不让任何人成为被崇拜的偶像。我自己一直受到同代人的过分的赞扬和尊敬，这不是由于我自己的过错，也不是由于我自己的功劳，而实在是一种命运的嘲弄。其原因大概在于人们有一种愿望，想理解我以自已微薄的绵力，通过不断的斗争所获得的少数几个观念，而这种愿望有很多人却未能实现。我完全明白，一个组织要实现它的目的，就必须有一个人去思考，去指挥、并且全面担负起责任来。但是被领导的人不应当受到强迫，他们必须能够选择自己的领袖。在我看来，强迫的专制制度很快就会腐化堕落。因为暴力所招引来的总是一些品德低劣的人；而且我相信，天才的暴君总是由无赖来继承的，这是一条千古不易的规律。就是由于这个缘故，我总强烈地反对今天在意大利和俄国所见到的那种制度。像欧洲今天所存在的情况，已使得民主形式受到怀疑，这不能归咎于民主原则本身，而是由于政府的不稳定和选举制度中与个人无关的特征。我相信美国在这方面已经找到了正确的道路。他们选出了一个任期足够长的总统，他有充分的权力来真正履行他的职责。另一方面，在德国政治制度中，为我所看重的是它为救济患病或贫困的人作出了可贵的广泛的规定。在人生的丰富多彩的表演中，我觉得真正可贵的，不是政治上的国家，而是有创造性的、有感情的个人，是人格；只有个人才能创造出高尚的和卓越的东西，而群众本身在思想上总是迟钝的，在感觉上也总是迟钝的。\n　讲到这里，我想起了群众生活中最坏的一种表现，那就是使我厌恶的军事制度。一个人能够洋洋得意的随着军乐队在四列纵队里行进，单凭这一点就足以使我对他鄙夷不屑。他所以长了一个大脑，只是出于误会；光是骨髓就可满足他的全部需要了。文明的这种罪恶的渊薮，应当尽快加以消灭。任人支配的英雄主义、冷酷无情的暴行，以及在爱国主义名义下的一切可恶的胡闹，所有这些都使我深恶痛绝！在我看来，战争是多么卑鄙、下流！我宁愿被千刀万剐，也不愿参与这种可憎的勾当。尽管如此，我对人类的评价还是十分高的。我相信，要是人民的健康感情没有遭到那些通过学校和报纸而起作用的商业利益和政治利益的蓄意败坏，那么战争这个妖魔早就该绝迹了。\n　我们能拥有的最美好的体验是探求奥秘的体验。它是坚守在真正艺术和真正科学发源地上的基本感情。谁要是体会不到它，谁要是不再有好奇心，也不再有惊讶的感觉，谁就无异于行尸走肉，他的眼睛便是模糊不清的。就是这种奥秘的体验──虽然掺杂着恐惧──产生了宗教。我们认识到有某种为我们所不能洞察的东西存在，感觉到那种只能以其最原始的形式接近我们的心灵的最深奥的理性和最灿烂的美──正是这种认识和这种情感构成了真正的宗教感情；在这个意义上，而且也只是在这个意义上，我才是一个具有深挚的宗教感情的人。我无法想象存在这样一个上帝，它会对自己的创造物加以赏罚，会具有我们在自己身上所体验到的那种意志。我不能也不愿去想象一个人在肉体死亡以后还会继续活着；让那些脆弱的灵魂，由于恐惧或者由于可笑的唯我论，去拿这种思想当宝贝吧！我自己只求满足于生命永恒的奥秘，满足于觉察现存世界的神奇结构，窥见它的一鳞半爪，并且以诚挚的努力去领悟在自然界中显示出来的那个理性的一部分，倘若真能如此，即使只领悟其极小的一部分，我也就心满意足了。\n★《乔布斯：在斯坦福大学的演讲》 　我十七岁的时候，读到了一句话：“如果你把每一天都当作生命中最后一天去生活的话，那么有一天你会发现自己是正确的。”这句话给我留下了深刻的印象。从那时开始，过了33年，我在每天早晨都会对着镜子问自己：“如果今天是我生命中的最后一天，我还会做今天要做的事情吗？”如果连续很多天得到否定的回答，那我就需要作出一些改变了。\n　“记住你即将死去”是我一生中遇到的最重要箴言。它帮我指明了生命中重要的选择。因为几乎所有的事情（包括所有的荣誉、所有的骄傲、所有对难堪和失败的恐惧），在死亡面前都会消失。我看到的是留下的真正重要的东西。\n　你有时候会思考你将要失去的东西，“记住你即将死去”是我知道的避免这些想法的最好办法。你已经赤身裸体了，你没有理由不去跟随自己的心一起跳动。\n　大概一年以前，我的一次体检结果清楚的显示在我的胰腺有一个肿瘤。医生告诉我那很可能是一种无法治愈的癌症，我还有三到六个月的时间活在这个世界上。我的医生叫我回家，然后整理好我的一切，那就是医生准备死亡的程序。那意味着你将要把未来十年对你小孩说的话在几个月里面说完；那意味着把每件事情都搞定，让你的家人会尽可能轻松的生活；那意味着你要说“再见了”。我整天和那个诊断书一起生活。后来有一天早上医生将一个内窥镜从我的喉咙伸进去，通过我的胃，然后进入我的肠子，用一根针在我的胰腺上的肿瘤上取了几个细胞。我当时很镇静，因为我被注射了镇定剂。但是我的妻子在那里，后来告诉我，当医生在显微镜地下观察这些细胞的时候他们开始尖叫，因为这些细胞最后竟然是一种非常罕见的、可以用手术治愈的胰腺癌细胞。我做了这个手术，现在我痊愈了。\n　那是我最接近死亡的时候，我还希望这也是以后的几十年最接近的一次。从死亡线上又活了过来，死亡对我来说，只是一个有用但是纯粹是知识上的概念的时候，我可以更肯定一点地对你们说：没有人愿意死，即使人们想上天堂，人们也不会为了去那里而死。但是死亡是我们每个人共同的终点。从来没有人能够逃脱它，也应该如此。因为死亡是生命中最好的一个发明。它把旧的清除以便给新的让路。你们现在是新的，但是从现在开始不久以后，你们将会逐渐的变成旧的然后被清除。这很有戏剧性，而事实就是如此。\n　你们的时间有限，所以不要浪费时间去重复别人的生活。不要被教条束缚，那意味着你和其他人思考的结果一起生活。不要被其他人喧嚣的观点掩盖你内心真正的想法。还有最重要的是，拥有追随自己内心与直觉的勇气——你的内心与直觉多少已经知道你真正想要成为什么样的人。与之相比，所有其它事情都是次要的。\n　当我年轻的时候，有一本振聋发聩的杂志叫做《全球概览》——它是我们那代人的圣经之一。一个叫 Stewart Brand 的家伙神奇地将这本杂志带到这个世界上。当时还是60年代末，所以这本书全部是用打字机、剪刀还有偏光镜制作的。Stewart 和他的伙伴出版了几期《全球概览》，当它完成了自己使命的时候，他们出了最后一期。在最后一期的封底上是清晨乡村公路的照片（如果你有冒险精神的话，你可以自己找到这条路的），在照片之下有这样一段话：“Stay Hungry, Stay Foolish”。这是他们停止了发刊的告别语。“Stay Hungry, Stay Foolish”，我总是希望自己能够那样。现在，在你们即将毕业，开始新的旅程的时候。我也希望你们能做到：Stay Hungry, Stay Foolish。\n★《王小波：工作与人生》 　我现在已经活到了人生的中途，拿一日来比喻人的一生，现在正是中午。人在童年时从朦胧中醒来，需要一些时间来克服清晨的软弱，然后就要投入工作；在正午时分，他的精力最为充沛，但已隐隐感到疲惫；到了黄昏时节，就要总结一日的工作，准备沉入永恒的休息。按我这种说法，工作是人一生的主题。这个想法不是人人都能同意的。我知道在中国，农村的人把生儿育女看作是一生的主题。把儿女养大，自己就死掉，给他们空出地方来——这是很流行的想法。在城市里则另有一种想法，但不知是不是很流行：它把取得社会地位看作一生的主题。站在北京八宝山的骨灰墙前，可以体会到这种想法。我在那里看到一位已故的大叔墓上写着：副系主任、支部副书记、副教授、某某教研室副主任，等等。假如能把这些“副”字去掉个把，对这位大叔当然更好一些，但这些“副”字最能证明有这样一种想法。顺便说一句，我到美国的公墓里看过，发现他们的墓碑上只写两件事：一是生卒年月，二是某年至某年服兵役；这就是说，他们以为人的一生只有这两件事值得记述：这位上帝的子民曾经来到尘世，以及这位公民曾去为国尽忠，写别的都是多余的，我觉得这种想法比较质朴……恐怕在一份青年刊物上写这些墓前的景物是太过伤感，还是及早回到正题上来罢。\n　我想要把自己对人生的看法推荐给青年朋友们：人从工作中可以得到乐趣，这是一种巨大的好处。相比之下，从金钱、权力、生育子女方面可以得到的快乐，总要受到制约。举例来说，现在把生育作为生活的主题，首先是不合时宜；其次，人在生育力方面比兔子大为不如，更不要说和黄花鱼相比较；在这方面很难取得无穷无尽的成就。我对权力没有兴趣，对钱有一些兴趣，但也不愿为它去受罪——做我想做的事（这件事对我来说，就是写小说），并且把它做好，这就是我的目标。我想，和我志趣相投的人总不会是一个都没有。\n　根据我的经验，人在年轻时，最头疼的一件事就是决定自己这一生要做什么。在这方面，我倒没有什么具体的建议：干什么都可以，但最好不要写小说，这是和我抢饭碗。当然，假如你执意要写，我也没理由反对。总而言之，干什么都是好的；但要干出个样子来，这才是人的价值和尊严所在。人在工作时，不单要用到手、腿和腰，还要用脑子和自己的心胸。我总觉得国人对这后一方面不够重视，这样就会把工作看成是受罪。失掉了快乐最主要的源泉，对生活的态度也会因之变得灰暗……\n　人活在世上，不但有身体，还有头脑和心胸——对此请勿从解剖学上理解。人脑是怎样的一种东西，科学还不能说清楚。心胸是怎么回事就更难说清。对我自己来说，心胸是我在生活中想要达到的最低目标。某件事有悖于我的心胸，我就认为它不值得一做；某个人有悖于我的心胸，我就觉得他不值得一交；某种生活有悖于我的心胸，我就会以为它不值得一过。罗素先生曾言，对人来说，不加检点的生活，确实不值得一过。我同意他的意见：不加检点的生活，属于不能接受的生活之一种。人必须过他可以接受的生活，这恰恰是他改变一切的动力。人有了心胸，就可以用它来改变自己的生活。\n　中国人喜欢接受这样的想法：只要能活着就是好的，活成什么样子无所谓。从一些电影的名字就可以看出来：《活着》、《找乐》……我对这种想法是断然地不赞成，因为抱有这种想法的人就可能活成任何一种糟糕的样子，从而使生活本身失去意义。高尚、清洁、充满乐趣的生活是好的，人们很容易得到共识。卑下、肮脏、贫乏的生活是不好的，这也能得到共识。但只有这两条远远不够。我以写作为生，我知道某种文章好，也知道某种文章坏。仅知道这两条尚不足以开始写作。还有更加重要的一条，那就是：某种样子的文章对我来说不可取，绝不能让它从我笔下写出来，冠以我的名字登在报刊上。以小喻大，这也是我对生活的态度。\n","description":"转载三篇有关于爱因斯坦对人生、政治、宗教的看法的著名演讲以及乔布斯在斯坦福大学的演讲、王小波对工作与人生的看法相关文章。","id":9,"section":"reproduced","tags":["转载",""],"title":"转载：关于人生","uri":"http://think.pengchangwen.site/reproduced/my-worldview/"},{"content":"Sample images from Pixabay\n","description":"cartoon gallery","id":10,"section":"gallery","tags":null,"title":"Cartoon","uri":"http://think.pengchangwen.site/gallery/cartoon/"},{"content":"Sample images from Pixabay\n","description":"photo gallery","id":11,"section":"gallery","tags":null,"title":"Photo","uri":"http://think.pengchangwen.site/gallery/photo/"},{"content":"　“根据我的经验，人在年轻时，最头疼的一件事就是决定自己这一生要做什么。在这方面，我倒没有什么具体的建议：干什么都可以，但最好不要写小说，这是和我抢饭碗。当然，假如你执意要写，我也没理由反对。总而言之，干什么都是好的；但要干出个样子来，这才是人的价值和尊严所在。人在工作时，不单要用到手、腿和腰，还要用脑子和自己的心胸。我总觉得国人对这后一方面不够重视，这样就会把工作看成是受罪。失掉了快乐最主要的源泉，对生活的态度也会因之变得灰暗……”——王小波\n","description":"Hugo, the world’s fastest framework for building websites","id":12,"section":"","tags":null,"title":"About","uri":"http://think.pengchangwen.site/about/"}]